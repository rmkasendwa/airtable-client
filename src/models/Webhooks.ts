/**
 * AUTO-GENERATED FILE
 *
 * WARNING: DO NOT MODIFY THIS FILE MANUALLY
 *
 * This file has been automatically generated by the @infinite-debugger/swagger-to-ts library.
 * Any manual changes made to this file will be overwritten the next time the library is run.
 * If you need to make changes to the TypeScript definitions, modify the OpenAPI specification file
 * and regenerate the TypeScript code using the @infinite-debugger/swagger-to-ts library.
 */

import { z } from 'zod';

//#region WebhookSpecificationIncludes
export const WebhookSpecificationIncludesValidationSchema = z.object({
  includeCellValuesInFieldIds: z
    .union([z.array(z.string()), z.literal('all')])
    .optional()
    .describe(
      'A list of fields to include in the payload regardless of whether or not they changed.'
    ),
  includePreviousCellValues: z
    .boolean()
    .optional()
    .describe('If true, include the previous cell value in the payload.'),
  includePreviousFieldDefinitions: z
    .boolean()
    .optional()
    .describe('If true, include the previous field definition in the payload.'),
});

export interface WebhookSpecificationIncludes {
  /**
   * A list of fields to include in the payload regardless of whether or not they changed.
   */
  includeCellValuesInFieldIds?: string[] | 'all';

  /**
   * If true, include the previous cell value in the payload.
   */
  includePreviousCellValues?: boolean;

  /**
   * If true, include the previous field definition in the payload.
   */
  includePreviousFieldDefinitions?: boolean;
}
//#endregion

//#region WebhookSpecificationSourceOptionsFormSubmission
export const WebhookSpecificationSourceOptionsFormSubmissionValidationSchema =
  z.object({ viewId: z.string() });

export interface WebhookSpecificationSourceOptionsFormSubmission {
  viewId: string;
}
//#endregion

//#region GenericError
export const GenericErrorValidationSchema = z.object({
  message: z.string().min(1).describe('An error message'),
  name: z.string().min(1).optional().describe('The error name'),
});

export interface GenericError {
  /**
   * An error message
   */
  message: string;

  /**
   * The error name
   */
  name?: string;
}
//#endregion

//#region CreateWebhookResponse
export const CreateWebhookResponseValidationSchema = z.object({
  expirationTime: z
    .string()
    .optional()
    .describe(
      'The time when the webhook expires and is disabled in the ISO format. The webhook will not expire if this is null (in the case User API keys are used)'
    ),
  id: z.string().describe('An identifier for the webhook (WebhookId).'),
  macSecretBase64: z
    .string()
    .describe(
      'A MAC secret. The client should store this value to authenticate webhook pings. There is no way to retrieve this value after the initial creation of the webhook.'
    ),
});

export interface CreateWebhookResponse {
  /**
   * The time when the webhook expires and is disabled in the ISO format. The webhook will not expire if this is null (in the case User API keys are used)
   */
  expirationTime?: string;

  /**
   * An identifier for the webhook (WebhookId).
   */
  id: string;

  /**
   * A MAC secret. The client should store this value to authenticate webhook pings. There is no way to retrieve this value after the initial creation of the webhook.
   */
  macSecretBase64: string;
}
//#endregion

//#region ToggleWebhookRequestPayload
export const ToggleWebhookRequestPayloadValidationSchema = z.object({
  enable: z.boolean(),
});

export interface ToggleWebhookRequestPayload {
  enable: boolean;
}
//#endregion

//#region WebhooksTableMetadata
export const WebhooksTableMetadataValidationSchema = z.object({
  description: z.string().optional(),
  name: z.string(),
});

export interface WebhooksTableMetadata {
  description?: string;

  name: string;
}
//#endregion

//#region TableField
export const TableFieldValidationSchema = z.object({
  type: z.literal('aiText').optional(),
});

export interface TableField {
  type?: 'aiText';
}
//#endregion

//#region WebhooksTableChangedMetadataField
export const WebhooksTableChangedMetadataFieldValidationSchema = z.object({
  description: z.string().optional(),
  name: z.string().optional(),
});

export interface WebhooksTableChangedMetadataField {
  description?: string;

  name?: string;
}
//#endregion

//#region WebhooksTableField
export const webhooksTableFieldTypeOptions = [
  'singleLineText',
  'email',
  'url',
  'multilineText',
  'number',
  'percent',
  'currency',
  'singleSelect',
  'multipleSelects',
  'singleCollaborator',
  'multipleCollaborators',
  'multipleRecordLinks',
  'date',
  'dateTime',
  'phoneNumber',
  'multipleAttachments',
  'checkbox',
  'formula',
  'createdTime',
  'rollup',
  'count',
  'lookup',
  'multipleLookupValues',
  'autoNumber',
  'barcode',
  'rating',
  'richText',
  'duration',
  'lastModifiedTime',
  'button',
  'createdBy',
  'lastModifiedBy',
  'externalSyncSource',
  'aiText',
] as const;

export type WebhooksTableFieldType =
  (typeof webhooksTableFieldTypeOptions)[number];

export const WebhooksTableFieldValidationSchema = z.object({
  name: z.string(),
  type: z.enum(webhooksTableFieldTypeOptions),
});

export interface WebhooksTableField {
  name: string;

  type: WebhooksTableFieldType;
}
//#endregion

//#region WebhookActionAutomationSourceMetadata
export const WebhookActionAutomationSourceMetadataValidationSchema = z.object({
  automationId: z.string(),
});

export interface WebhookActionAutomationSourceMetadata {
  automationId: string;
}
//#endregion

//#region WebhookActionFormSubmissionSourceMetadata
export const WebhookActionFormSubmissionSourceMetadataValidationSchema =
  z.object({ viewId: z.string() });

export interface WebhookActionFormSubmissionSourceMetadata {
  viewId: string;
}
//#endregion

//#region WebhooksUser
export const webhooksUserPermissionLevelOptions = [
  'none',
  'read',
  'comment',
  'edit',
  'create',
] as const;

export type WebhooksUserPermissionLevel =
  (typeof webhooksUserPermissionLevelOptions)[number];

export const WebhooksUserValidationSchema = z.object({
  email: z.string(),
  id: z.string(),
  name: z.string().optional(),
  permissionLevel: z.enum(webhooksUserPermissionLevelOptions),
  profilePicUrl: z.string().optional(),
});

export interface WebhooksUser {
  email: string;

  id: string;

  name?: string;

  permissionLevel: WebhooksUserPermissionLevel;

  profilePicUrl?: string;
}
//#endregion

//#region WebhookAction
export const webhookActionSourceOptions = [
  'client',
  'publicApi',
  'formSubmission',
  'automation',
  'system',
  'sync',
  'anonymousUser',
] as const;

export type WebhookActionSource = (typeof webhookActionSourceOptions)[number];

export const WebhookActionValidationSchema = z.object({
  source: z.enum(webhookActionSourceOptions),
  sourceMetadata: z
    .union([
      WebhookActionClientSourceMetadataValidationSchema,
      WebhookActionFormSubmissionSourceMetadataValidationSchema,
      WebhookActionAutomationSourceMetadataValidationSchema,
    ])
    .optional(),
});

export interface WebhookAction {
  source: WebhookActionSource;

  sourceMetadata?:
    | WebhookActionClientSourceMetadata
    | WebhookActionFormSubmissionSourceMetadata
    | WebhookActionAutomationSourceMetadata;
}
//#endregion

//#region FindAllWebhookPayloadsQueryParams
export const FindAllWebhookPayloadsQueryParamsValidationSchema = z.object({
  cursor: z
    .number()
    .optional()
    .describe(
      'The first time this action is called, the cursor argument may be omitted from the request and will default to 1. After that, cursors should be saved between invocations of this action. When a client receives a ping, it should use the last cursor that this action returned when polling for new payloads, no matter how old that cursor value is. The cursor argument indicates the transaction number of the payload to start listing from.'
    ),
  limit: z
    .number()
    .optional()
    .describe(
      'If given the limit parameter specifies the maximum number of payloads to return in the response. A maximum of 50 payloads can be returned in a single request. A single payload can contain multiple updates.'
    ),
});

export interface FindAllWebhookPayloadsQueryParams {
  /**
   * The first time this action is called, the cursor argument may be omitted from the request and will default to 1. After that, cursors should be saved between invocations of this action. When a client receives a ping, it should use the last cursor that this action returned when polling for new payloads, no matter how old that cursor value is. The cursor argument indicates the transaction number of the payload to start listing from.
   */
  cursor?: number;

  /**
   * If given the limit parameter specifies the maximum number of payloads to return in the response. A maximum of 50 payloads can be returned in a single request. A single payload can contain multiple updates.
   */
  limit?: number;
}
//#endregion

//#region RefreshWebhookResponse
export const RefreshWebhookResponseValidationSchema = z.object({
  expirationTime: z
    .string()
    .describe(
      'The new time when the webhook will expire and be disabled in the ISO format.'
    ),
});

export interface RefreshWebhookResponse {
  /**
   * The new time when the webhook will expire and be disabled in the ISO format.
   */
  expirationTime: string;
}
//#endregion

//#region WebhookSpecificationSourceOptions
export const WebhookSpecificationSourceOptionsValidationSchema = z.object({
  formSubmission:
    WebhookSpecificationSourceOptionsFormSubmissionValidationSchema.optional(),
});

export interface WebhookSpecificationSourceOptions {
  formSubmission?: WebhookSpecificationSourceOptionsFormSubmission;
}
//#endregion

//#region WebhookSpecificationOptionsFilters
export const webhookSpecificationOptionsFiltersChangeTypeOptions = [
  'add',
  'remove',
  'update',
] as const;

export type WebhookSpecificationOptionsFiltersChangeType =
  (typeof webhookSpecificationOptionsFiltersChangeTypeOptions)[number];

export const webhookSpecificationOptionsFiltersDataTypeOptions = [
  'tableData',
  'tableFields',
  'tableMetadata',
] as const;

export type WebhookSpecificationOptionsFiltersDataType =
  (typeof webhookSpecificationOptionsFiltersDataTypeOptions)[number];

export const webhookSpecificationOptionsFiltersFromSourceOptions = [
  'client',
  'publicApi',
  'formSubmission',
  'automation',
  'system',
  'sync',
  'anonymousUser',
  'unknown',
] as const;

export type WebhookSpecificationOptionsFiltersFromSource =
  (typeof webhookSpecificationOptionsFiltersFromSourceOptions)[number];

export const WebhookSpecificationOptionsFiltersValidationSchema = z.object({
  changeTypes: z
    .array(z.enum(webhookSpecificationOptionsFiltersChangeTypeOptions))
    .optional()
    .describe('Only generate payloads that contain changes of these types.'),
  dataTypes: z
    .array(z.enum(webhookSpecificationOptionsFiltersDataTypeOptions))
    .describe(
      'Only generate payloads that contain changes affecting objects of these types.\n\ntableData: record and cell value changes\ntableFields: field changes\ntableMetadata: table name and description changes'
    ),
  fromSources: z
    .array(z.enum(webhookSpecificationOptionsFiltersFromSourceOptions))
    .optional()
    .describe(
      'Only generate payloads for changes from these sources. If omitted, changes from all sources are reported.\n\nclient: changes generated by a user through the web or mobile clients\npublicApi: changes generated through the Airtable API\nformSubmission: changes generated when a form is submitted\nautomation: changes generated through an automation action\nsystem: changes generated by system events, such as processing time function formulas\nsync: changes generated through Airtable Sync'
    ),
  recordChangeScope: z
    .string()
    .optional()
    .describe(
      'Only generate payloads for changes in the specified TableId or ViewId.'
    ),
  sourceOptions: z
    .array(WebhookSpecificationSourceOptionsValidationSchema)
    .optional()
    .describe(
      'Additional options for source filtering. This allows users to filter form submissions by ViewId.'
    ),
  watchDataInFieldIds: z
    .array(z.string())
    .optional()
    .describe(
      'Only generate payloads for changes that modify values in cells in these fields. If omitted, all fields within the table/view/base are watched.'
    ),
  watchSchemasOfFieldIds: z
    .array(z.string())
    .optional()
    .describe(
      'Only generate payloads for changes that modify the schemas of these fields. If omitted, schemas of all fields within the table/view/base are watched.'
    ),
});

export interface WebhookSpecificationOptionsFilters {
  /**
   * Only generate payloads that contain changes of these types.
   */
  changeTypes?: WebhookSpecificationOptionsFiltersChangeType[];

  /**
   * Only generate payloads that contain changes affecting objects of these types.
   *
   * tableData: record and cell value changes
   * tableFields: field changes
   * tableMetadata: table name and description changes
   */
  dataTypes: WebhookSpecificationOptionsFiltersDataType[];

  /**
   * Only generate payloads for changes from these sources. If omitted, changes from all sources are reported.
   *
   * client: changes generated by a user through the web or mobile clients
   * publicApi: changes generated through the Airtable API
   * formSubmission: changes generated when a form is submitted
   * automation: changes generated through an automation action
   * system: changes generated by system events, such as processing time function formulas
   * sync: changes generated through Airtable Sync
   */
  fromSources?: WebhookSpecificationOptionsFiltersFromSource[];

  /**
   * Only generate payloads for changes in the specified TableId or ViewId.
   */
  recordChangeScope?: string;

  /**
   * Additional options for source filtering. This allows users to filter form submissions by ViewId.
   */
  sourceOptions?: WebhookSpecificationSourceOptions[];

  /**
   * Only generate payloads for changes that modify values in cells in these fields. If omitted, all fields within the table/view/base are watched.
   */
  watchDataInFieldIds?: string[];

  /**
   * Only generate payloads for changes that modify the schemas of these fields. If omitted, schemas of all fields within the table/view/base are watched.
   */
  watchSchemasOfFieldIds?: string[];
}
//#endregion

//#region WebhookSpecificationOptions
export const WebhookSpecificationOptionsValidationSchema = z.object({
  filters: WebhookSpecificationOptionsFiltersValidationSchema,
  includes: WebhookSpecificationIncludesValidationSchema.optional(),
});

export interface WebhookSpecificationOptions {
  filters: WebhookSpecificationOptionsFilters;

  includes?: WebhookSpecificationIncludes;
}
//#endregion

//#region WebhookSpecification
export const WebhookSpecificationValidationSchema = z.object({
  options: WebhookSpecificationOptionsValidationSchema,
});

export interface WebhookSpecification {
  options: WebhookSpecificationOptions;
}
//#endregion

//#region WebhookNotification
export const WebhookNotificationValidationSchema = z.object({
  completionTimestamp: z
    .string()
    .describe('The time of the most recent notification.'),
  durationMs: z
    .number()
    .describe('The roundtrip duration of the network call.'),
  error: GenericErrorValidationSchema.optional().describe(
    'Object containing the error message.'
  ),
  retryNumber: z
    .number()
    .describe(
      'The number of times the notification was retried. (0 = first try)'
    ),
  success: z.boolean(),
  willBeRetried: z
    .boolean()
    .optional()
    .describe(
      'Whether or not Airtable will attempt to deliver a notification again.'
    ),
});

export interface WebhookNotification {
  /**
   * The time of the most recent notification.
   */
  completionTimestamp: string;

  /**
   * The roundtrip duration of the network call.
   */
  durationMs: number;

  /**
   * Object containing the error message.
   */
  error?: GenericError;

  /**
   * The number of times the notification was retried. (0 = first try)
   */
  retryNumber: number;

  success: boolean;

  /**
   * Whether or not Airtable will attempt to deliver a notification again.
   */
  willBeRetried?: boolean;
}
//#endregion

//#region Webhook
export const WebhookValidationSchema = z.object({
  areNotificationsEnabled: z
    .boolean()
    .describe('Whether or not notifications are enabled for the webhook.'),
  cursorForNextPayload: z
    .number()
    .describe(
      'The cursor associated with the next payload that will be generated. This cursor will increase every time a new payload is generated for this webhook.'
    ),
  expirationTime: z
    .string()
    .optional()
    .describe(
      'The time when the webhook expires and is disabled in the ISO format. The webhook will not expire if this is null (in the case User API keys are used)'
    ),
  id: z.string().describe('An identifier for the webhook (WebhookId).'),
  isHookEnabled: z
    .boolean()
    .describe(
      'Whether or not the webhook is enabled. Webhooks may be turned off automatically such as when the specification becomes invalid. [See error codes](https://airtable.com/developers/web/api/model/webhooks-payload).'
    ),
  lastNotificationResult: WebhookNotificationValidationSchema.optional(),
  lastSuccessfulNotificationTime: z
    .string()
    .optional()
    .describe('An identifier for the created webhook.'),
  notificationUrl: z
    .string()
    .optional()
    .describe(
      'The url registered with the webhook. May be null if none was given.'
    ),
  specification: WebhookSpecificationValidationSchema.describe(
    'The specification registered with the webhook.'
  ),
});

export interface Webhook {
  /**
   * Whether or not notifications are enabled for the webhook.
   */
  areNotificationsEnabled: boolean;

  /**
   * The cursor associated with the next payload that will be generated. This cursor will increase every time a new payload is generated for this webhook.
   */
  cursorForNextPayload: number;

  /**
   * The time when the webhook expires and is disabled in the ISO format. The webhook will not expire if this is null (in the case User API keys are used)
   */
  expirationTime?: string;

  /**
   * An identifier for the webhook (WebhookId).
   */
  id: string;

  /**
   * Whether or not the webhook is enabled. Webhooks may be turned off automatically such as when the specification becomes invalid. [See error codes](https://airtable.com/developers/web/api/model/webhooks-payload).
   */
  isHookEnabled: boolean;

  lastNotificationResult?: WebhookNotification;

  /**
   * An identifier for the created webhook.
   */
  lastSuccessfulNotificationTime?: string;

  /**
   * The url registered with the webhook. May be null if none was given.
   */
  notificationUrl?: string;

  /**
   * The specification registered with the webhook.
   */
  specification: WebhookSpecification;
}
//#endregion

//#region FindAllWebhooksResponse
export const FindAllWebhooksResponseValidationSchema = z.object({
  webhooks: z
    .array(WebhookValidationSchema)
    .describe('An array of objects containing webhook objects.'),
});

export interface FindAllWebhooksResponse {
  /**
   * An array of objects containing webhook objects.
   */
  webhooks: Webhook[];
}
//#endregion

//#region Unauthorized
export const UnauthorizedValidationSchema = z.object({
  errors: z
    .array(GenericErrorValidationSchema)
    .optional()
    .describe('A list of related errors'),
  message: z.string().min(1).describe('An error message'),
  name: z.string().min(1).describe('The error name'),
  stack: z
    .string()
    .optional()
    .describe('The stack trace (only in development mode)'),
  status: z.number().describe('The status code of the exception'),
});

export interface Unauthorized {
  /**
   * A list of related errors
   */
  errors?: GenericError[];

  /**
   * An error message
   */
  message: string;

  /**
   * The error name
   *
   * @example "UNAUTHORIZED"
   *
   * @default "UNAUTHORIZED"
   */
  name: string;

  /**
   * The stack trace (only in development mode)
   */
  stack?: string;

  /**
   * The status code of the exception
   *
   * @example 401
   *
   * @default 401
   */
  status: number;
}
//#endregion

//#region CreateWebhookRequestPayload
export const CreateWebhookRequestPayloadValidationSchema = z.object({
  notificationUrl: z
    .string()
    .optional()
    .describe(
      'An optional url that can receive notification pings. [See notification delivery](https://airtable.com/developers/web/api/webhooks-overview#webhook-notification-delivery).'
    ),
  specification: WebhookSpecificationValidationSchema.describe(
    'A JSON object that describe the types of changes the webhook is interested in.'
  ),
});

export interface CreateWebhookRequestPayload {
  /**
   * An optional url that can receive notification pings. [See notification delivery](https://airtable.com/developers/web/api/webhooks-overview#webhook-notification-delivery).
   */
  notificationUrl?: string;

  /**
   * A JSON object that describe the types of changes the webhook is interested in.
   */
  specification: WebhookSpecification;
}
//#endregion

//#region WebhooksTableCreated
export const WebhooksTableCreatedValidationSchema = z.object({
  fieldsById: z
    .record(WebhooksTableFieldValidationSchema)
    .optional()
    .describe('The below object is keyed with a string'),
  metadata: WebhooksTableMetadataValidationSchema.optional(),
  recordsById: z
    .record(WebhooksTableRecordValidationSchema)
    .optional()
    .describe('The below object is keyed with a string'),
});

export interface WebhooksTableCreated {
  /**
   * The below object is keyed with a string
   */
  fieldsById?: Record<string, WebhooksTableField>;

  metadata?: WebhooksTableMetadata;

  /**
   * The below object is keyed with a string
   */
  recordsById?: Record<string, WebhooksTableRecord>;
}
//#endregion

//#region WebhooksTableRecord
export const WebhooksTableRecordValidationSchema = z.object({
  cellValuesByFieldId: TableFieldValidationSchema,
  createdTime: z
    .string()
    .describe(
      'A date timestamp in the ISO format, eg:"2018-01-01T00:00:00.000Z"'
    ),
});

export interface WebhooksTableRecord {
  cellValuesByFieldId: TableField;

  /**
   * A date timestamp in the ISO format, eg:"2018-01-01T00:00:00.000Z"
   */
  createdTime: string;
}
//#endregion

//#region WebhooksViewCreatedRecordsById
export const WebhooksViewCreatedRecordsByIdValidationSchema = z.object({
  cellValuesByFieldId: z.record(TableFieldValidationSchema).optional(),
  createdTime: z
    .string()
    .optional()
    .describe(
      'A date timestamp in the ISO format, eg:"2018-01-01T00:00:00.000Z"'
    ),
});

export interface WebhooksViewCreatedRecordsById {
  cellValuesByFieldId?: Record<string, TableField>;

  /**
   * A date timestamp in the ISO format, eg:"2018-01-01T00:00:00.000Z"
   */
  createdTime?: string;
}
//#endregion

//#region WebhooksViewChanged
export const WebhooksViewChangedValidationSchema = z.object({
  changedRecordsById: z
    .record(WebhooksViewChangedRecordsByIdValidationSchema)
    .optional()
    .describe('Changed events are generated when a record in a view changes.'),
  createdRecordsById: z
    .record(WebhooksViewCreatedRecordsByIdValidationSchema)
    .optional()
    .describe(
      'Create events when a record is added or made visible to a view.'
    ),
  destroyedRecordIds: z
    .array(z.string())
    .optional()
    .describe(
      'Destroyed events are generated when a record is deleted or removed from a view.'
    ),
});

export interface WebhooksViewChanged {
  /**
   * Changed events are generated when a record in a view changes.
   */
  changedRecordsById?: Record<string, WebhooksViewChangedRecordsById>;

  /**
   * Create events when a record is added or made visible to a view.
   */
  createdRecordsById?: Record<string, WebhooksViewCreatedRecordsById>;

  /**
   * Destroyed events are generated when a record is deleted or removed from a view.
   */
  destroyedRecordIds?: string[];
}
//#endregion

//#region WebhooksViewChangedRecordsById
export const WebhooksViewChangedRecordsByIdValidationSchema = z.object({
  current: TableFieldValidationSchema.optional(),
  previous: TableFieldValidationSchema.optional(),
  unchanged: TableFieldValidationSchema.optional(),
});

export interface WebhooksViewChangedRecordsById {
  current?: TableField;

  previous?: TableField;

  unchanged?: TableField;
}
//#endregion

//#region WebhooksTableChangedMetadata
export const WebhooksTableChangedMetadataValidationSchema = z.object({
  current: WebhooksTableChangedMetadataFieldValidationSchema.optional(),
  previous: WebhooksTableChangedMetadataFieldValidationSchema.optional(),
});

export interface WebhooksTableChangedMetadata {
  current?: WebhooksTableChangedMetadataField;

  previous?: WebhooksTableChangedMetadataField;
}
//#endregion

//#region WebhooksTableChangedFields
export const WebhooksTableChangedFieldsValidationSchema = z.object({
  current: WebhooksTableFieldValidationSchema.optional(),
  previous: WebhooksTableFieldValidationSchema.optional(),
});

export interface WebhooksTableChangedFields {
  current?: WebhooksTableField;

  previous?: WebhooksTableField;
}
//#endregion

//#region WebhooksTableChanged
export const WebhooksTableChangedValidationSchema = z.object({
  changedFieldsById: z
    .record(WebhooksTableChangedFieldsValidationSchema)
    .optional()
    .describe('The below object is keyed with a string'),
  changedMetadata: WebhooksTableChangedMetadataValidationSchema.optional(),
  changedRecordsById: z
    .record(WebhooksViewChangedRecordsByIdValidationSchema)
    .optional()
    .describe('The below object is keyed with a string'),
  changedViewsById: z
    .record(WebhooksViewChangedValidationSchema)
    .optional()
    .describe(
      'This is only included when recordChangeScope is a view id.\n\nThe below object is keyed with a string'
    ),
  createdFieldsById: z
    .record(WebhooksTableFieldValidationSchema)
    .optional()
    .describe('The below object is keyed with a string'),
  createdRecordsById: z
    .record(WebhooksTableRecordValidationSchema)
    .optional()
    .describe('The below object is keyed with a string'),
  destroyedFieldIds: z.array(z.string()).optional(),
  destroyedRecordIds: z.array(z.string()).optional(),
});

export interface WebhooksTableChanged {
  /**
   * The below object is keyed with a string
   */
  changedFieldsById?: Record<string, WebhooksTableChangedFields>;

  changedMetadata?: WebhooksTableChangedMetadata;

  /**
   * The below object is keyed with a string
   */
  changedRecordsById?: Record<string, WebhooksViewChangedRecordsById>;

  /**
   * This is only included when recordChangeScope is a view id.
   *
   * The below object is keyed with a string
   */
  changedViewsById?: Record<string, WebhooksViewChanged>;

  /**
   * The below object is keyed with a string
   */
  createdFieldsById?: Record<string, WebhooksTableField>;

  /**
   * The below object is keyed with a string
   */
  createdRecordsById?: Record<string, WebhooksTableRecord>;

  destroyedFieldIds?: string[];

  destroyedRecordIds?: string[];
}
//#endregion

//#region WebhookActionClientSourceMetadata
export const WebhookActionClientSourceMetadataValidationSchema = z.object({
  user: WebhooksUserValidationSchema,
});

export interface WebhookActionClientSourceMetadata {
  user: WebhooksUser;
}
//#endregion

//#region WebhookPayload
export const webhookPayloadCodeOptions = [
  'INVALID_FILTERS',
  'INVALID_HOOK',
] as const;

export type WebhookPayloadCode = (typeof webhookPayloadCodeOptions)[number];

export const WebhookPayloadValidationSchema = z.object({
  actionMetadata: WebhookActionValidationSchema.describe(
    'The action responsible for the change. We may add additional sources or source metadata in the future and this will not be considered a breaking change. API consumers are expected to handle unknown sources gracefully.'
  ),
  baseTransactionNumber: z
    .number()
    .describe(
      'A number which can be used to determine all changes within a transaction.'
    ),
  changedTablesById: z.record(WebhooksTableChangedValidationSchema).optional(),
  code: z
    .enum(webhookPayloadCodeOptions)
    .optional()
    .describe(
      'Additional error codes may be introduced, and will not be considered a breaking change.\n\nIn addition INTERNAL_ERROR can be returned if an internal error is encountered'
    ),
  createdTablesById: z.record(WebhooksTableCreatedValidationSchema).optional(),
  destroyedTableIds: z.array(z.string()).optional(),
  error: z.boolean().optional(),
  payloadFormat: z
    .literal('v0')
    .describe(
      "The payload format's version number. This is currently just v0, but it may be increased in the future for breaking payload changes."
    ),
  timestamp: z.string().describe('The time the action occurred.'),
});

export interface WebhookPayload {
  /**
   * The action responsible for the change. We may add additional sources or source metadata in the future and this will not be considered a breaking change. API consumers are expected to handle unknown sources gracefully.
   */
  actionMetadata: WebhookAction;

  /**
   * A number which can be used to determine all changes within a transaction.
   */
  baseTransactionNumber: number;

  changedTablesById?: Record<string, WebhooksTableChanged>;

  /**
   * Additional error codes may be introduced, and will not be considered a breaking change.
   *
   * In addition INTERNAL_ERROR can be returned if an internal error is encountered
   */
  code?: WebhookPayloadCode;

  createdTablesById?: Record<string, WebhooksTableCreated>;

  destroyedTableIds?: string[];

  error?: boolean;

  /**
   * The payload format's version number. This is currently just v0, but it may be increased in the future for breaking payload changes.
   */
  payloadFormat: 'v0';

  /**
   * The time the action occurred.
   */
  timestamp: string;
}
//#endregion

//#region FindAllWebhookPayloadsResponse
export const FindAllWebhookPayloadsResponseValidationSchema = z.object({
  cursor: z
    .number()
    .describe(
      "The cursor field in the response indicates the transaction number of the payload that would immediately follow the last payload returned in this request. Payloads are returned in transaction order, so the last payload's transaction number is (cursor-1), the second-to-last payload's transaction number is (cursor-2), and so on. Each payload is associated with an incrementing cursor number. If there are no returned payloads, then the cursor in the response will be the same as the cursor specified in the request. The number of the next payload to be generated can be retrieved from cursorForNextPayload in [list webhooks](https://airtable.com/developers/web/api/list-webhooks). Payloads are deleted from Airtable's servers after 1 week whether or not the client has seen them. The cursor value for the next payload is never reset, even if payloads are deleted."
    ),
  mightHaveMore: z
    .boolean()
    .describe(
      'Indicates whether or not there are additional payloads. If mightHaveMore is true, the client should send another request immediately and pass in the cursor from this response.'
    ),
  payloads: z.array(WebhookPayloadValidationSchema),
});

export interface FindAllWebhookPayloadsResponse {
  /**
   * The cursor field in the response indicates the transaction number of the payload that would immediately follow the last payload returned in this request. Payloads are returned in transaction order, so the last payload's transaction number is (cursor-1), the second-to-last payload's transaction number is (cursor-2), and so on. Each payload is associated with an incrementing cursor number. If there are no returned payloads, then the cursor in the response will be the same as the cursor specified in the request. The number of the next payload to be generated can be retrieved from cursorForNextPayload in [list webhooks](https://airtable.com/developers/web/api/list-webhooks). Payloads are deleted from Airtable's servers after 1 week whether or not the client has seen them. The cursor value for the next payload is never reset, even if payloads are deleted.
   */
  cursor: number;

  /**
   * Indicates whether or not there are additional payloads. If mightHaveMore is true, the client should send another request immediately and pass in the cursor from this response.
   */
  mightHaveMore: boolean;

  payloads: WebhookPayload[];
}
//#endregion
