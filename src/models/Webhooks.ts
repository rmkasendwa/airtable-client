/**
 * AUTO-GENERATED FILE
 *
 * WARNING: DO NOT MODIFY THIS FILE MANUALLY
 *
 * This file has been automatically generated by the @infinite-debugger/swagger-to-ts library.
 * Any manual changes made to this file will be overwritten the next time the library is run.
 * If you need to make changes to the TypeScript definitions, modify the OpenAPI specification file
 * and regenerate the TypeScript code using the @infinite-debugger/swagger-to-ts library.
 */

import { z } from 'zod';

//#region WebhookSpecificationIncludes
export const WebhookSpecificationIncludesValidationSchema = z.object({
  includeCellValuesInFieldIds: z
    .union([z.array(z.string()), z.literal('all')])
    .optional()
    .describe(
      'A list of fields to include in the payload regardless of whether or not they changed.'
    ),
  includePreviousCellValues: z
    .boolean()
    .optional()
    .describe('If true, include the previous cell value in the payload.'),
  includePreviousFieldDefinitions: z
    .boolean()
    .optional()
    .describe('If true, include the previous field definition in the payload.'),
});

export interface WebhookSpecificationIncludes {
  /**
   * A list of fields to include in the payload regardless of whether or not they changed.
   */
  includeCellValuesInFieldIds?: string[] | 'all';

  /**
   * If true, include the previous cell value in the payload.
   */
  includePreviousCellValues?: boolean;

  /**
   * If true, include the previous field definition in the payload.
   */
  includePreviousFieldDefinitions?: boolean;
}
//#endregion

//#region WebhookSpecificationSourceOptionsFormSubmission
export const WebhookSpecificationSourceOptionsFormSubmissionValidationSchema =
  z.object({ viewId: z.string() });

export interface WebhookSpecificationSourceOptionsFormSubmission {
  viewId: string;
}
//#endregion

//#region GenericError
export const GenericErrorValidationSchema = z.object({
  message: z.string().min(1).describe('An error message'),
  name: z.string().min(1).optional().describe('The error name'),
});

export interface GenericError {
  /**
   * An error message
   */
  message: string;

  /**
   * The error name
   */
  name?: string;
}
//#endregion

//#region CreateWebhookResponse
export const CreateWebhookResponseValidationSchema = z.object({
  expirationTime: z
    .string()
    .optional()
    .describe(
      'The time when the webhook expires and is disabled in the ISO format. The webhook will not expire if this is null (in the case User API keys are used)'
    ),
  id: z.string().describe('An identifier for the webhook (WebhookId).'),
  macSecretBase64: z
    .string()
    .describe(
      'A MAC secret. The client should store this value to authenticate webhook pings. There is no way to retrieve this value after the initial creation of the webhook.'
    ),
});

export interface CreateWebhookResponse {
  /**
   * The time when the webhook expires and is disabled in the ISO format. The webhook will not expire if this is null (in the case User API keys are used)
   */
  expirationTime?: string;

  /**
   * An identifier for the webhook (WebhookId).
   */
  id: string;

  /**
   * A MAC secret. The client should store this value to authenticate webhook pings. There is no way to retrieve this value after the initial creation of the webhook.
   */
  macSecretBase64: string;
}
//#endregion

//#region ToggleWebhookRequestPayload
export const ToggleWebhookRequestPayloadValidationSchema = z.object({
  enable: z.boolean(),
});

export interface ToggleWebhookRequestPayload {
  enable: boolean;
}
//#endregion

//#region RefreshWebhookResponse
export const RefreshWebhookResponseValidationSchema = z.object({
  expirationTime: z
    .string()
    .describe(
      'The new time when the webhook will expire and be disabled in the ISO format.'
    ),
});

export interface RefreshWebhookResponse {
  /**
   * The new time when the webhook will expire and be disabled in the ISO format.
   */
  expirationTime: string;
}
//#endregion

//#region WebhookSpecificationSourceOptions
export const WebhookSpecificationSourceOptionsValidationSchema = z.object({
  formSubmission:
    WebhookSpecificationSourceOptionsFormSubmissionValidationSchema.optional(),
});

export interface WebhookSpecificationSourceOptions {
  formSubmission?: WebhookSpecificationSourceOptionsFormSubmission;
}
//#endregion

//#region WebhookSpecificationOptionsFilters
export const webhookSpecificationOptionsFiltersChangeTypeOptions = [
  'add',
  'remove',
  'update',
] as const;

export type WebhookSpecificationOptionsFiltersChangeType =
  (typeof webhookSpecificationOptionsFiltersChangeTypeOptions)[number];

export const webhookSpecificationOptionsFiltersDataTypeOptions = [
  'tableData',
  'tableFields',
  'tableMetadata',
] as const;

export type WebhookSpecificationOptionsFiltersDataType =
  (typeof webhookSpecificationOptionsFiltersDataTypeOptions)[number];

export const webhookSpecificationOptionsFiltersFromSourceOptions = [
  'client',
  'publicApi',
  'formSubmission',
  'automation',
  'system',
  'sync',
  'anonymousUser',
  'unknown',
] as const;

export type WebhookSpecificationOptionsFiltersFromSource =
  (typeof webhookSpecificationOptionsFiltersFromSourceOptions)[number];

export const WebhookSpecificationOptionsFiltersValidationSchema = z.object({
  changeTypes: z
    .array(z.enum(webhookSpecificationOptionsFiltersChangeTypeOptions))
    .optional()
    .describe('Only generate payloads that contain changes of these types.'),
  dataTypes: z
    .array(z.enum(webhookSpecificationOptionsFiltersDataTypeOptions))
    .describe(
      'Only generate payloads that contain changes affecting objects of these types.\n\ntableData: record and cell value changes\ntableFields: field changes\ntableMetadata: table name and description changes'
    ),
  fromSources: z
    .array(z.enum(webhookSpecificationOptionsFiltersFromSourceOptions))
    .optional()
    .describe(
      'Only generate payloads for changes from these sources. If omitted, changes from all sources are reported.\n\nclient: changes generated by a user through the web or mobile clients\npublicApi: changes generated through the Airtable API\nformSubmission: changes generated when a form is submitted\nautomation: changes generated through an automation action\nsystem: changes generated by system events, such as processing time function formulas\nsync: changes generated through Airtable Sync'
    ),
  recordChangeScope: z
    .string()
    .optional()
    .describe(
      'Only generate payloads for changes in the specified TableId or ViewId.'
    ),
  sourceOptions: z
    .array(WebhookSpecificationSourceOptionsValidationSchema)
    .optional()
    .describe(
      'Additional options for source filtering. This allows users to filter form submissions by ViewId.'
    ),
  watchDataInFieldIds: z
    .array(z.string())
    .optional()
    .describe(
      'Only generate payloads for changes that modify values in cells in these fields. If omitted, all fields within the table/view/base are watched.'
    ),
  watchSchemasOfFieldIds: z
    .array(z.string())
    .optional()
    .describe(
      'Only generate payloads for changes that modify the schemas of these fields. If omitted, schemas of all fields within the table/view/base are watched.'
    ),
});

export interface WebhookSpecificationOptionsFilters {
  /**
   * Only generate payloads that contain changes of these types.
   */
  changeTypes?: WebhookSpecificationOptionsFiltersChangeType[];

  /**
   * Only generate payloads that contain changes affecting objects of these types.
   *
   * tableData: record and cell value changes
   * tableFields: field changes
   * tableMetadata: table name and description changes
   */
  dataTypes: WebhookSpecificationOptionsFiltersDataType[];

  /**
   * Only generate payloads for changes from these sources. If omitted, changes from all sources are reported.
   *
   * client: changes generated by a user through the web or mobile clients
   * publicApi: changes generated through the Airtable API
   * formSubmission: changes generated when a form is submitted
   * automation: changes generated through an automation action
   * system: changes generated by system events, such as processing time function formulas
   * sync: changes generated through Airtable Sync
   */
  fromSources?: WebhookSpecificationOptionsFiltersFromSource[];

  /**
   * Only generate payloads for changes in the specified TableId or ViewId.
   */
  recordChangeScope?: string;

  /**
   * Additional options for source filtering. This allows users to filter form submissions by ViewId.
   */
  sourceOptions?: WebhookSpecificationSourceOptions[];

  /**
   * Only generate payloads for changes that modify values in cells in these fields. If omitted, all fields within the table/view/base are watched.
   */
  watchDataInFieldIds?: string[];

  /**
   * Only generate payloads for changes that modify the schemas of these fields. If omitted, schemas of all fields within the table/view/base are watched.
   */
  watchSchemasOfFieldIds?: string[];
}
//#endregion

//#region WebhookSpecificationOptions
export const WebhookSpecificationOptionsValidationSchema = z.object({
  filters: WebhookSpecificationOptionsFiltersValidationSchema,
  includes: WebhookSpecificationIncludesValidationSchema.optional(),
});

export interface WebhookSpecificationOptions {
  filters: WebhookSpecificationOptionsFilters;

  includes?: WebhookSpecificationIncludes;
}
//#endregion

//#region WebhookSpecification
export const WebhookSpecificationValidationSchema = z.object({
  options: WebhookSpecificationOptionsValidationSchema,
});

export interface WebhookSpecification {
  options: WebhookSpecificationOptions;
}
//#endregion

//#region WebhookNotification
export const WebhookNotificationValidationSchema = z.object({
  completionTimestamp: z
    .string()
    .describe('The time of the most recent notification.'),
  durationMs: z
    .number()
    .describe('The roundtrip duration of the network call.'),
  error: GenericErrorValidationSchema.optional().describe(
    'Object containing the error message.'
  ),
  retryNumber: z
    .number()
    .describe(
      'The number of times the notification was retried. (0 = first try)'
    ),
  success: z.boolean(),
  willBeRetried: z
    .boolean()
    .optional()
    .describe(
      'Whether or not Airtable will attempt to deliver a notification again.'
    ),
});

export interface WebhookNotification {
  /**
   * The time of the most recent notification.
   */
  completionTimestamp: string;

  /**
   * The roundtrip duration of the network call.
   */
  durationMs: number;

  /**
   * Object containing the error message.
   */
  error?: GenericError;

  /**
   * The number of times the notification was retried. (0 = first try)
   */
  retryNumber: number;

  success: boolean;

  /**
   * Whether or not Airtable will attempt to deliver a notification again.
   */
  willBeRetried?: boolean;
}
//#endregion

//#region Webhook
export const WebhookValidationSchema = z.object({
  areNotificationsEnabled: z
    .boolean()
    .describe('Whether or not notifications are enabled for the webhook.'),
  cursorForNextPayload: z
    .number()
    .describe(
      'The cursor associated with the next payload that will be generated. This cursor will increase every time a new payload is generated for this webhook.'
    ),
  expirationTime: z
    .string()
    .optional()
    .describe(
      'The time when the webhook expires and is disabled in the ISO format. The webhook will not expire if this is null (in the case User API keys are used)'
    ),
  id: z.string().describe('An identifier for the webhook (WebhookId).'),
  isHookEnabled: z
    .boolean()
    .describe(
      'Whether or not the webhook is enabled. Webhooks may be turned off automatically such as when the specification becomes invalid. [See error codes](https://airtable.com/developers/web/api/model/webhooks-payload).'
    ),
  lastNotificationResult: WebhookNotificationValidationSchema.optional(),
  lastSuccessfulNotificationTime: z
    .string()
    .optional()
    .describe('An identifier for the created webhook.'),
  notificationUrl: z
    .string()
    .optional()
    .describe(
      'The url registered with the webhook. May be null if none was given.'
    ),
  specification: WebhookSpecificationValidationSchema.describe(
    'The specification registered with the webhook.'
  ),
});

export interface Webhook {
  /**
   * Whether or not notifications are enabled for the webhook.
   */
  areNotificationsEnabled: boolean;

  /**
   * The cursor associated with the next payload that will be generated. This cursor will increase every time a new payload is generated for this webhook.
   */
  cursorForNextPayload: number;

  /**
   * The time when the webhook expires and is disabled in the ISO format. The webhook will not expire if this is null (in the case User API keys are used)
   */
  expirationTime?: string;

  /**
   * An identifier for the webhook (WebhookId).
   */
  id: string;

  /**
   * Whether or not the webhook is enabled. Webhooks may be turned off automatically such as when the specification becomes invalid. [See error codes](https://airtable.com/developers/web/api/model/webhooks-payload).
   */
  isHookEnabled: boolean;

  lastNotificationResult?: WebhookNotification;

  /**
   * An identifier for the created webhook.
   */
  lastSuccessfulNotificationTime?: string;

  /**
   * The url registered with the webhook. May be null if none was given.
   */
  notificationUrl?: string;

  /**
   * The specification registered with the webhook.
   */
  specification: WebhookSpecification;
}
//#endregion

//#region FindAllWebhooksResponse
export const FindAllWebhooksResponseValidationSchema = z.object({
  webhooks: z
    .array(WebhookValidationSchema)
    .describe('An array of objects containing webhook objects.'),
});

export interface FindAllWebhooksResponse {
  /**
   * An array of objects containing webhook objects.
   */
  webhooks: Webhook[];
}
//#endregion

//#region Unauthorized
export const UnauthorizedValidationSchema = z.object({
  errors: z
    .array(GenericErrorValidationSchema)
    .optional()
    .describe('A list of related errors'),
  message: z.string().min(1).describe('An error message'),
  name: z.string().min(1).describe('The error name'),
  stack: z
    .string()
    .optional()
    .describe('The stack trace (only in development mode)'),
  status: z.number().describe('The status code of the exception'),
});

export interface Unauthorized {
  /**
   * A list of related errors
   */
  errors?: GenericError[];

  /**
   * An error message
   */
  message: string;

  /**
   * The error name
   *
   * @example "UNAUTHORIZED"
   *
   * @default "UNAUTHORIZED"
   */
  name: string;

  /**
   * The stack trace (only in development mode)
   */
  stack?: string;

  /**
   * The status code of the exception
   *
   * @example 401
   *
   * @default 401
   */
  status: number;
}
//#endregion

//#region CreateWebhookRequestPayload
export const CreateWebhookRequestPayloadValidationSchema = z.object({
  notificationUrl: z
    .string()
    .optional()
    .describe(
      'An optional url that can receive notification pings. [See notification delivery](https://airtable.com/developers/web/api/webhooks-overview#webhook-notification-delivery).'
    ),
  specification: WebhookSpecificationValidationSchema.describe(
    'A JSON object that describe the types of changes the webhook is interested in.'
  ),
});

export interface CreateWebhookRequestPayload {
  /**
   * An optional url that can receive notification pings. [See notification delivery](https://airtable.com/developers/web/api/webhooks-overview#webhook-notification-delivery).
   */
  notificationUrl?: string;

  /**
   * A JSON object that describe the types of changes the webhook is interested in.
   */
  specification: WebhookSpecification;
}
//#endregion
