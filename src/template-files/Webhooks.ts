/**
 * AUTO-GENERATED FILE
 *
 * WARNING: DO NOT MODIFY THIS FILE MANUALLY
 *
 * This file has been automatically generated by the @infinite-debugger/swagger-to-ts library.
 * Any manual changes made to this file will be overwritten the next time the library is run.
 * If you need to make changes to the TypeScript definitions, modify the OpenAPI specification file
 * and regenerate the TypeScript code using the @infinite-debugger/swagger-to-ts library.
 */

import { removeNullValues } from '@infinite-debugger/rmk-utils';
import {
  TemplatePath,
  addSearchParams,
  getInterpolatedPath,
} from '@infinite-debugger/rmk-utils/paths';
import { AxiosResponse } from 'axios';

import { RequestOptions, _delete, get, post } from '../api/Adapter';
import {
  CreateWebhookRequestPayload,
  CreateWebhookResponse,
  CreateWebhookResponseValidationSchema,
  FindAllWebhookPayloadsQueryParams,
  FindAllWebhookPayloadsResponse,
  FindAllWebhookPayloadsResponseValidationSchema,
  FindAllWebhooksResponse,
  FindAllWebhooksResponseValidationSchema,
  RefreshWebhookResponse,
  RefreshWebhookResponseValidationSchema,
  ToggleWebhookRequestPayload,
} from '../models/Webhooks';

//#region Endpoint Paths
export const FIND_ALL_WEBHOOKS_ENDPOINT_PATH: TemplatePath<{ baseId: string }> =
  '/bases/{baseId}/webhooks';
export const CREATE_NEW_WEBHOOK_ENDPOINT_PATH: TemplatePath<{
  baseId: string;
}> = '/bases/{baseId}/webhooks';
export const DELETE_EXISTING_WEBHOOK_ENDPOINT_PATH: TemplatePath<{
  baseId: string;
  webhookId: string;
}> = '/bases/{baseId}/webhooks/{webhookId}';
export const TOGGLE_WEBHOOK_NOTIFICATIONS_ENDPOINT_PATH: TemplatePath<{
  baseId: string;
  webhookId: string;
}> = '/bases/{baseId}/webhooks/{webhookId}/enableNotifications';
export const FIND_ALL_WEBHOOK_PAYLOADS_ENDPOINT_PATH: TemplatePath<{
  baseId: string;
  webhookId: string;
}> = '/bases/{baseId}/webhooks/{webhookId}/payloads';
export const REFRESH_WEBHOOK_ENDPOINT_PATH: TemplatePath<{
  baseId: string;
  webhookId: string;
}> = '/bases/{baseId}/webhooks/{webhookId}/refresh';
//#endregion

//#region Data Keys
export const WEBHOOKS_DATA_KEY = 'Webhooks';
//#endregion

//#region API
//#region Find All Webhooks
/**
 * Lists all webhooks that are registered for a base, along with their statuses.
 *
 * @param baseId
 * @returns The response that contains the list of webhooks.
 */
export async function findAllWebhooks(
  baseId: string
): Promise<FindAllWebhooksResponse>;

/**
 * Lists all webhooks that are registered for a base, along with their statuses.
 *
 * @param baseId
 * @param options The request options.
 * @returns The response that contains the list of webhooks.
 */
export async function findAllWebhooks(
  baseId: string,
  options?: RequestOptions<FindAllWebhooksResponse> & {
    unWrapResponse?: undefined;
  }
): Promise<FindAllWebhooksResponse>;

/**
 * Lists all webhooks that are registered for a base, along with their statuses.
 *
 * @param baseId
 * @param options The request options.
 * @returns The response that contains the list of webhooks.
 */
export async function findAllWebhooks(
  baseId: string,
  options?: RequestOptions<FindAllWebhooksResponse> & {
    unWrapResponse?: false;
  }
): Promise<AxiosResponse<FindAllWebhooksResponse>>;

/**
 * Lists all webhooks that are registered for a base, along with their statuses.
 *
 * @param baseId
 * @param options The request options.
 * @returns The response that contains the list of webhooks.
 */
export async function findAllWebhooks(
  baseId: string,
  options?: RequestOptions<FindAllWebhooksResponse> & {
    unWrapResponse?: true;
  }
): Promise<FindAllWebhooksResponse>;

/**
 * Lists all webhooks that are registered for a base, along with their statuses.
 *
 * @param baseId
 * @param options The request options.
 * @returns The response that contains the list of webhooks.
 */
export async function findAllWebhooks(
  baseId: string,
  {
    unWrapResponse = true,
    ...rest
  }: RequestOptions<FindAllWebhooksResponse> & {
    unWrapResponse?: boolean;
  } = {}
) {
  if (rest.getStaleWhileRevalidate) {
    const baseGetStaleWhileRevalidate = rest.getStaleWhileRevalidate;
    rest.getStaleWhileRevalidate = (data) => {
      return baseGetStaleWhileRevalidate(
        FindAllWebhooksResponseValidationSchema.parse(removeNullValues(data))
      );
    };
  }

  const response = await get(
    getInterpolatedPath(FIND_ALL_WEBHOOKS_ENDPOINT_PATH, {
      baseId,
    }),
    {
      label: 'Find All Webhooks',
      cacheId: WEBHOOKS_DATA_KEY,
      ...rest,
    }
  );

  const data = FindAllWebhooksResponseValidationSchema.parse(
    removeNullValues(response.data)
  );

  if (unWrapResponse) {
    return data;
  }

  return {
    ...response,
    data,
  };
}
//#endregion

//#region Create New Webhook
/**
 * Creates a new webhook in the specified base. Payloads may be generated and the notification URL (if given) will get a ping shortly after this completes.
 *
 * The number of webhooks per base is limited to 10. A single OAuth integration can create up to 2 webhooks per base.
 *
 * Each webhook created with OAuth or personal access token will expire and be disabled after 7 days. The webhook life can be extended while it is still active by calling refresh webhook or list webhook payloads. After a webhook has expired and been disabled, the webhook's metadata and past payloads can be accessed for an additional 7 days.
 *
 * @param baseId
 * @param requestPayload
 * @returns The response that contains the list of webhooks.
 */
export async function createNewWebhook(
  baseId: string,
  requestPayload: CreateWebhookRequestPayload
): Promise<CreateWebhookResponse>;

/**
 * Creates a new webhook in the specified base. Payloads may be generated and the notification URL (if given) will get a ping shortly after this completes.
 *
 * The number of webhooks per base is limited to 10. A single OAuth integration can create up to 2 webhooks per base.
 *
 * Each webhook created with OAuth or personal access token will expire and be disabled after 7 days. The webhook life can be extended while it is still active by calling refresh webhook or list webhook payloads. After a webhook has expired and been disabled, the webhook's metadata and past payloads can be accessed for an additional 7 days.
 *
 * @param baseId
 * @param requestPayload
 * @param options The request options.
 * @returns The response that contains the list of webhooks.
 */
export async function createNewWebhook(
  baseId: string,
  requestPayload: CreateWebhookRequestPayload,
  options?: RequestOptions<CreateWebhookResponse> & {
    unWrapResponse?: undefined;
  }
): Promise<CreateWebhookResponse>;

/**
 * Creates a new webhook in the specified base. Payloads may be generated and the notification URL (if given) will get a ping shortly after this completes.
 *
 * The number of webhooks per base is limited to 10. A single OAuth integration can create up to 2 webhooks per base.
 *
 * Each webhook created with OAuth or personal access token will expire and be disabled after 7 days. The webhook life can be extended while it is still active by calling refresh webhook or list webhook payloads. After a webhook has expired and been disabled, the webhook's metadata and past payloads can be accessed for an additional 7 days.
 *
 * @param baseId
 * @param requestPayload
 * @param options The request options.
 * @returns The response that contains the list of webhooks.
 */
export async function createNewWebhook(
  baseId: string,
  requestPayload: CreateWebhookRequestPayload,
  options?: RequestOptions<CreateWebhookResponse> & {
    unWrapResponse?: false;
  }
): Promise<AxiosResponse<CreateWebhookResponse>>;

/**
 * Creates a new webhook in the specified base. Payloads may be generated and the notification URL (if given) will get a ping shortly after this completes.
 *
 * The number of webhooks per base is limited to 10. A single OAuth integration can create up to 2 webhooks per base.
 *
 * Each webhook created with OAuth or personal access token will expire and be disabled after 7 days. The webhook life can be extended while it is still active by calling refresh webhook or list webhook payloads. After a webhook has expired and been disabled, the webhook's metadata and past payloads can be accessed for an additional 7 days.
 *
 * @param baseId
 * @param requestPayload
 * @param options The request options.
 * @returns The response that contains the list of webhooks.
 */
export async function createNewWebhook(
  baseId: string,
  requestPayload: CreateWebhookRequestPayload,
  options?: RequestOptions<CreateWebhookResponse> & {
    unWrapResponse?: true;
  }
): Promise<CreateWebhookResponse>;

/**
 * Creates a new webhook in the specified base. Payloads may be generated and the notification URL (if given) will get a ping shortly after this completes.
 *
 * The number of webhooks per base is limited to 10. A single OAuth integration can create up to 2 webhooks per base.
 *
 * Each webhook created with OAuth or personal access token will expire and be disabled after 7 days. The webhook life can be extended while it is still active by calling refresh webhook or list webhook payloads. After a webhook has expired and been disabled, the webhook's metadata and past payloads can be accessed for an additional 7 days.
 *
 * @param baseId
 * @param requestPayload
 * @param options The request options.
 * @returns The response that contains the list of webhooks.
 */
export async function createNewWebhook(
  baseId: string,
  requestPayload: CreateWebhookRequestPayload,
  {
    unWrapResponse = true,
    ...rest
  }: RequestOptions<CreateWebhookResponse> & {
    unWrapResponse?: boolean;
  } = {}
) {
  if (rest.getStaleWhileRevalidate) {
    const baseGetStaleWhileRevalidate = rest.getStaleWhileRevalidate;
    rest.getStaleWhileRevalidate = (data) => {
      return baseGetStaleWhileRevalidate(
        CreateWebhookResponseValidationSchema.parse(removeNullValues(data))
      );
    };
  }

  const response = await post(
    getInterpolatedPath(CREATE_NEW_WEBHOOK_ENDPOINT_PATH, {
      baseId,
    }),
    {
      label: 'Create New Webhook',
      data: requestPayload,
      ...rest,
    }
  );

  const data = CreateWebhookResponseValidationSchema.parse(
    removeNullValues(response.data)
  );

  if (unWrapResponse) {
    return data;
  }

  return {
    ...response,
    data,
  };
}
//#endregion

//#region Delete Existing Webhook
/**
 * Deletes a webhook.
 *
 * @param baseId
 * @param webhookId
 */
export async function deleteExistingWebhook(
  baseId: string,
  webhookId: string
): Promise<any>;

/**
 * Deletes a webhook.
 *
 * @param baseId
 * @param webhookId
 * @param options The request options.
 */
export async function deleteExistingWebhook(
  baseId: string,
  webhookId: string,
  options?: RequestOptions<any> & {
    unWrapResponse?: undefined;
  }
): Promise<any>;

/**
 * Deletes a webhook.
 *
 * @param baseId
 * @param webhookId
 * @param options The request options.
 */
export async function deleteExistingWebhook(
  baseId: string,
  webhookId: string,
  options?: RequestOptions<any> & {
    unWrapResponse?: false;
  }
): Promise<AxiosResponse<any>>;

/**
 * Deletes a webhook.
 *
 * @param baseId
 * @param webhookId
 * @param options The request options.
 */
export async function deleteExistingWebhook(
  baseId: string,
  webhookId: string,
  options?: RequestOptions<any> & {
    unWrapResponse?: true;
  }
): Promise<any>;

/**
 * Deletes a webhook.
 *
 * @param baseId
 * @param webhookId
 * @param options The request options.
 */
export async function deleteExistingWebhook(
  baseId: string,
  webhookId: string,
  {
    unWrapResponse = true,
    ...rest
  }: RequestOptions<any> & {
    unWrapResponse?: boolean;
  } = {}
) {
  if (rest.getStaleWhileRevalidate) {
    const baseGetStaleWhileRevalidate = rest.getStaleWhileRevalidate;
    rest.getStaleWhileRevalidate = (data) => {
      return baseGetStaleWhileRevalidate(data);
    };
  }

  const response = await _delete(
    getInterpolatedPath(DELETE_EXISTING_WEBHOOK_ENDPOINT_PATH, {
      baseId,
      webhookId,
    }),
    {
      label: 'Delete Existing Webhook',
      responseType: 'blob',
      ...rest,
    }
  );

  const data = response.data;

  if (unWrapResponse) {
    return data;
  }

  return {
    ...response,
    data,
  };
}
//#endregion

//#region Toggle Webhook Notifications
/**
 * Enables or disables notification pings for a webhook. See [notification delivery](https://airtable.com/developers/web/api/webhooks-overview#webhook-notification-delivery).
 *
 * @param baseId
 * @param webhookId
 * @param requestPayload
 */
export async function toggleWebhookNotifications(
  baseId: string,
  webhookId: string,
  requestPayload: ToggleWebhookRequestPayload
): Promise<any>;

/**
 * Enables or disables notification pings for a webhook. See [notification delivery](https://airtable.com/developers/web/api/webhooks-overview#webhook-notification-delivery).
 *
 * @param baseId
 * @param webhookId
 * @param requestPayload
 * @param options The request options.
 */
export async function toggleWebhookNotifications(
  baseId: string,
  webhookId: string,
  requestPayload: ToggleWebhookRequestPayload,
  options?: RequestOptions<any> & {
    unWrapResponse?: undefined;
  }
): Promise<any>;

/**
 * Enables or disables notification pings for a webhook. See [notification delivery](https://airtable.com/developers/web/api/webhooks-overview#webhook-notification-delivery).
 *
 * @param baseId
 * @param webhookId
 * @param requestPayload
 * @param options The request options.
 */
export async function toggleWebhookNotifications(
  baseId: string,
  webhookId: string,
  requestPayload: ToggleWebhookRequestPayload,
  options?: RequestOptions<any> & {
    unWrapResponse?: false;
  }
): Promise<AxiosResponse<any>>;

/**
 * Enables or disables notification pings for a webhook. See [notification delivery](https://airtable.com/developers/web/api/webhooks-overview#webhook-notification-delivery).
 *
 * @param baseId
 * @param webhookId
 * @param requestPayload
 * @param options The request options.
 */
export async function toggleWebhookNotifications(
  baseId: string,
  webhookId: string,
  requestPayload: ToggleWebhookRequestPayload,
  options?: RequestOptions<any> & {
    unWrapResponse?: true;
  }
): Promise<any>;

/**
 * Enables or disables notification pings for a webhook. See [notification delivery](https://airtable.com/developers/web/api/webhooks-overview#webhook-notification-delivery).
 *
 * @param baseId
 * @param webhookId
 * @param requestPayload
 * @param options The request options.
 */
export async function toggleWebhookNotifications(
  baseId: string,
  webhookId: string,
  requestPayload: ToggleWebhookRequestPayload,
  {
    unWrapResponse = true,
    ...rest
  }: RequestOptions<any> & {
    unWrapResponse?: boolean;
  } = {}
) {
  if (rest.getStaleWhileRevalidate) {
    const baseGetStaleWhileRevalidate = rest.getStaleWhileRevalidate;
    rest.getStaleWhileRevalidate = (data) => {
      return baseGetStaleWhileRevalidate(data);
    };
  }

  const response = await post(
    getInterpolatedPath(TOGGLE_WEBHOOK_NOTIFICATIONS_ENDPOINT_PATH, {
      baseId,
      webhookId,
    }),
    {
      label: 'Toggle Webhook Notifications',
      data: requestPayload,
      responseType: 'blob',
      ...rest,
    }
  );

  const data = response.data;

  if (unWrapResponse) {
    return data;
  }

  return {
    ...response,
    data,
  };
}
//#endregion

//#region Find All Webhook Payloads
/**
 * Enumerate the update messages for a client to consume. Clients should call this after they receive a ping.
 *
 * The webhook payload format can be found [here](https://airtable.com/developers/web/api/model/webhooks-payload) and uses [V2 cell value format](https://airtable.com/developers/web/api/field-model).
 *
 * Calling this endpoint will also extend the life of the webhook if it is active with an expiration time. The new expiration time will be 7 days after the list payloads call.
 *
 * @param baseId
 * @param webhookId
 * @param queryParams
 * @returns The response that contains the list of webhook payloads.
 */
export async function findAllWebhookPayloads(
  baseId: string,
  webhookId: string,
  queryParams?: FindAllWebhookPayloadsQueryParams
): Promise<FindAllWebhookPayloadsResponse>;

/**
 * Enumerate the update messages for a client to consume. Clients should call this after they receive a ping.
 *
 * The webhook payload format can be found [here](https://airtable.com/developers/web/api/model/webhooks-payload) and uses [V2 cell value format](https://airtable.com/developers/web/api/field-model).
 *
 * Calling this endpoint will also extend the life of the webhook if it is active with an expiration time. The new expiration time will be 7 days after the list payloads call.
 *
 * @param baseId
 * @param webhookId
 * @param queryParams
 * @param options The request options.
 * @returns The response that contains the list of webhook payloads.
 */
export async function findAllWebhookPayloads(
  baseId: string,
  webhookId: string,
  queryParams?: FindAllWebhookPayloadsQueryParams,
  options?: RequestOptions<FindAllWebhookPayloadsResponse> & {
    unWrapResponse?: undefined;
  }
): Promise<FindAllWebhookPayloadsResponse>;

/**
 * Enumerate the update messages for a client to consume. Clients should call this after they receive a ping.
 *
 * The webhook payload format can be found [here](https://airtable.com/developers/web/api/model/webhooks-payload) and uses [V2 cell value format](https://airtable.com/developers/web/api/field-model).
 *
 * Calling this endpoint will also extend the life of the webhook if it is active with an expiration time. The new expiration time will be 7 days after the list payloads call.
 *
 * @param baseId
 * @param webhookId
 * @param queryParams
 * @param options The request options.
 * @returns The response that contains the list of webhook payloads.
 */
export async function findAllWebhookPayloads(
  baseId: string,
  webhookId: string,
  queryParams?: FindAllWebhookPayloadsQueryParams,
  options?: RequestOptions<FindAllWebhookPayloadsResponse> & {
    unWrapResponse?: false;
  }
): Promise<AxiosResponse<FindAllWebhookPayloadsResponse>>;

/**
 * Enumerate the update messages for a client to consume. Clients should call this after they receive a ping.
 *
 * The webhook payload format can be found [here](https://airtable.com/developers/web/api/model/webhooks-payload) and uses [V2 cell value format](https://airtable.com/developers/web/api/field-model).
 *
 * Calling this endpoint will also extend the life of the webhook if it is active with an expiration time. The new expiration time will be 7 days after the list payloads call.
 *
 * @param baseId
 * @param webhookId
 * @param queryParams
 * @param options The request options.
 * @returns The response that contains the list of webhook payloads.
 */
export async function findAllWebhookPayloads(
  baseId: string,
  webhookId: string,
  queryParams?: FindAllWebhookPayloadsQueryParams,
  options?: RequestOptions<FindAllWebhookPayloadsResponse> & {
    unWrapResponse?: true;
  }
): Promise<FindAllWebhookPayloadsResponse>;

/**
 * Enumerate the update messages for a client to consume. Clients should call this after they receive a ping.
 *
 * The webhook payload format can be found [here](https://airtable.com/developers/web/api/model/webhooks-payload) and uses [V2 cell value format](https://airtable.com/developers/web/api/field-model).
 *
 * Calling this endpoint will also extend the life of the webhook if it is active with an expiration time. The new expiration time will be 7 days after the list payloads call.
 *
 * @param baseId
 * @param webhookId
 * @param queryParams
 * @param options The request options.
 * @returns The response that contains the list of webhook payloads.
 */
export async function findAllWebhookPayloads(
  baseId: string,
  webhookId: string,
  queryParams: FindAllWebhookPayloadsQueryParams = {},
  {
    unWrapResponse = true,
    ...rest
  }: RequestOptions<FindAllWebhookPayloadsResponse> & {
    unWrapResponse?: boolean;
  } = {}
) {
  if (rest.getStaleWhileRevalidate) {
    const baseGetStaleWhileRevalidate = rest.getStaleWhileRevalidate;
    rest.getStaleWhileRevalidate = (data) => {
      return baseGetStaleWhileRevalidate(
        FindAllWebhookPayloadsResponseValidationSchema.parse(
          removeNullValues(data)
        )
      );
    };
  }

  const response = await get(
    addSearchParams(
      getInterpolatedPath(FIND_ALL_WEBHOOK_PAYLOADS_ENDPOINT_PATH, {
        baseId,
        webhookId,
      }),
      { ...queryParams },
      {
        arrayParamStyle: 'append',
      }
    ),
    {
      label: 'Find All Webhook Payloads',
      cacheId: WEBHOOKS_DATA_KEY,
      ...rest,
    }
  );

  const data = FindAllWebhookPayloadsResponseValidationSchema.parse(
    removeNullValues(response.data)
  );

  if (unWrapResponse) {
    return data;
  }

  return {
    ...response,
    data,
  };
}
//#endregion

//#region Refresh Webhook
/**
 * Extend the life of a webhook. The new expiration time will be 7 days after the refresh time.
 *
 * Note that this endpoint only applies to active webhooks with an expiration time.
 *
 * @param baseId
 * @param webhookId
 * @returns This endpoint returns an empty response on success.
 */
export async function refreshWebhook(
  baseId: string,
  webhookId: string
): Promise<RefreshWebhookResponse>;

/**
 * Extend the life of a webhook. The new expiration time will be 7 days after the refresh time.
 *
 * Note that this endpoint only applies to active webhooks with an expiration time.
 *
 * @param baseId
 * @param webhookId
 * @param options The request options.
 * @returns This endpoint returns an empty response on success.
 */
export async function refreshWebhook(
  baseId: string,
  webhookId: string,
  options?: RequestOptions<RefreshWebhookResponse> & {
    unWrapResponse?: undefined;
  }
): Promise<RefreshWebhookResponse>;

/**
 * Extend the life of a webhook. The new expiration time will be 7 days after the refresh time.
 *
 * Note that this endpoint only applies to active webhooks with an expiration time.
 *
 * @param baseId
 * @param webhookId
 * @param options The request options.
 * @returns This endpoint returns an empty response on success.
 */
export async function refreshWebhook(
  baseId: string,
  webhookId: string,
  options?: RequestOptions<RefreshWebhookResponse> & {
    unWrapResponse?: false;
  }
): Promise<AxiosResponse<RefreshWebhookResponse>>;

/**
 * Extend the life of a webhook. The new expiration time will be 7 days after the refresh time.
 *
 * Note that this endpoint only applies to active webhooks with an expiration time.
 *
 * @param baseId
 * @param webhookId
 * @param options The request options.
 * @returns This endpoint returns an empty response on success.
 */
export async function refreshWebhook(
  baseId: string,
  webhookId: string,
  options?: RequestOptions<RefreshWebhookResponse> & {
    unWrapResponse?: true;
  }
): Promise<RefreshWebhookResponse>;

/**
 * Extend the life of a webhook. The new expiration time will be 7 days after the refresh time.
 *
 * Note that this endpoint only applies to active webhooks with an expiration time.
 *
 * @param baseId
 * @param webhookId
 * @param options The request options.
 * @returns This endpoint returns an empty response on success.
 */
export async function refreshWebhook(
  baseId: string,
  webhookId: string,
  {
    unWrapResponse = true,
    ...rest
  }: RequestOptions<RefreshWebhookResponse> & {
    unWrapResponse?: boolean;
  } = {}
) {
  if (rest.getStaleWhileRevalidate) {
    const baseGetStaleWhileRevalidate = rest.getStaleWhileRevalidate;
    rest.getStaleWhileRevalidate = (data) => {
      return baseGetStaleWhileRevalidate(
        RefreshWebhookResponseValidationSchema.parse(removeNullValues(data))
      );
    };
  }

  const response = await post(
    getInterpolatedPath(REFRESH_WEBHOOK_ENDPOINT_PATH, {
      baseId,
      webhookId,
    }),
    {
      label: 'Refresh Webhook',
      ...rest,
    }
  );

  const data = RefreshWebhookResponseValidationSchema.parse(
    removeNullValues(response.data)
  );

  if (unWrapResponse) {
    return data;
  }

  return {
    ...response,
    data,
  };
}
//#endregion
//#endregion
