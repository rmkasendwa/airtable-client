import '@infinite-debugger/rmk-js-extensions/RegExp';
import '@infinite-debugger/rmk-js-extensions/String';

import { dirname, join, normalize, sep } from 'path';

import {
  ensureDirSync,
  existsSync,
  readFileSync,
  unlinkSync,
  writeFileSync,
} from 'fs-extra';
import { isEmpty } from 'lodash';
import prettier from 'prettier';
import { default as walk, default as walkSync } from 'walk-sync';

import { pkg } from '../config';
import { Config } from '../models';
import {
  getEntityTemplateFileInterpolationBlocks,
  getEntityTemplateFileInterpolationLabels,
} from './InterpolationValuesGenerator';
import { extractUserDefinedBasesAndTables } from './UserConfigTableExtractor';
import {
  ModuleImports,
  addModuleImport,
  cleanEmptyFoldersRecursively,
  getGeneratedFileWarningComment,
  getImportsCode,
} from './Utils';

const prettierConfig: prettier.Options = {
  semi: true,
  trailingComma: 'es5',
  singleQuote: true,
  printWidth: 80,
  tabWidth: 2,
  endOfLine: 'auto',
};

const airtableAPIFolderName = 'Airtable';

export interface GenerateAirtableAPIConfig {
  userConfig: Config<string>;
  outputRootPath: string;
  generateAllTables?: boolean;
}

export const generateAirtableAPI = async ({
  userConfig,
  outputRootPath,
  generateAllTables = false,
}: GenerateAirtableAPIConfig) => {
  //#region Initialization
  console.log('Generating airtable API...');
  const autogeneratedFileWarningComment = getGeneratedFileWarningComment();
  //#endregion

  const includeAirtableSpecificQueryParameters =
    userConfig.includeAirtableSpecificQueryParameters;

  const outputFolderPath = normalize(
    `${outputRootPath}/${airtableAPIFolderName}`
  );

  //#region Template files
  const templatesFolderPath = normalize(join(__dirname, '../template-files'));
  const airtableBaseScopedTemplateFiles = ['models/Utils.ts'].map(
    (fileName) => {
      return normalize(join(templatesFolderPath, fileName));
    }
  );
  const airtableTableScopedTemplateFilePaths = walk(templatesFolderPath, {
    includeBasePath: true,
    directories: false,
  })
    .map((filePath) => normalize(filePath))
    .filter((filePath) => {
      return (
        !filePath.match(/\.(template|placeholder)\.\w+$/g) &&
        !airtableBaseScopedTemplateFiles.includes(filePath)
      );
    });
  const modulePermissionsTemplate = readFileSync(
    join(
      __dirname,
      '../template-files/permissions/__entity_permissions_group.template.txt'
    ),
    'utf-8'
  );
  //#endregion

  const { bases: workingBases } = await extractUserDefinedBasesAndTables({
    userConfig,
    generateAllTables,
  });

  if (workingBases.length > 0) {
    //#region Clean up output directory
    if (existsSync(outputRootPath)) {
      walkSync(outputRootPath, {
        includeBasePath: true,
        directories: false,
      }).forEach((filePath) => {
        const fileContents = readFileSync(filePath, 'utf8');
        if (
          fileContents.match(
            `automatically generated by the ${pkg.name} library`
          )
        ) {
          console.log(`  -> Removing file: ${filePath}`);
          unlinkSync(filePath);
        }
      });
      cleanEmptyFoldersRecursively(outputRootPath);
    }
    ensureDirSync(outputFolderPath);
    //#endregion

    //#region Processing each focus airtable base
    workingBases.forEach(async (workingBase) => {
      const { name: workingBaseName, userDefinedTables, tables } = workingBase;

      //#region Prcess base if focus tables are found
      if (userDefinedTables.length > 0) {
        console.log(
          `\nProcessing \x1b[34m${workingBaseName.trim()}\x1b[0m base...`
        );

        const pascalCaseBaseName = workingBaseName.toPascalCase();
        const baseAPIOutputFolderPath = normalize(
          `${outputFolderPath}/${pascalCaseBaseName}`
        );

        //#region Permissions exports
        const permissionsImports: ModuleImports = {};
        const permissionsExports: string[] = [];
        const permissionsObjectStrings: string[] = [];
        //#endregion

        //#region Processing each focus tables.
        const filteredTablesConfigurations = await Promise.all(
          userDefinedTables.map(async (table) => {
            const {
              name: tableName,
              userDefinedViews: filteredViews,
              labelPlural,
              labelSingular,
              alternativeRecordIdColumns,
              nonLookupTableColumns,
              lookupTableColumns,
              editableTableColumns,
              nonLookupColumnNameToObjectPropertyMapper,
              lookupColumnNameToObjectPropertyMapper,
              airtableAPIModelImportsCollector,
              restAPIModelImportsCollector,
              queryableLookupFields,
              queryableNonLookupFields,
              restAPIModelExtrasCollector,
              columnNameToValidationSchemaTypeStringGroupMapper,
              lookupColumnNameToParentColumnNameMap,
            } = table;

            console.log(
              `  -> Processing \x1b[34m${workingBaseName.trim()}/${JSON.stringify(
                tableName
              )}\x1b[0m table...`
            );

            //#region Getting interpolation block replacement map
            const interpolationBlocks =
              getEntityTemplateFileInterpolationBlocks({
                base: workingBase,
                currentTable: table,
                nonLookupTableColumns,
                lookupTableColumns,
                editableTableColumns,
                tables,
                nonLookupColumnNameToObjectPropertyMapper,
                lookupColumnNameToObjectPropertyMapper,
                airtableAPIModelImportsCollector,
                restAPIModelImportsCollector,
                queryableLookupFields,
                queryableNonLookupFields,
                restAPIModelExtrasCollector,
                columnNameToValidationSchemaTypeStringGroupMapper,
                includeAirtableSpecificQueryParameters,
                alternativeRecordIdColumns,
              });
            //#endregion

            //#region Getting interpolation string replacement map
            const interpolationLabels =
              getEntityTemplateFileInterpolationLabels({
                currentTable: table,
                nonLookupTableColumns,
                lookupTableColumns,
                tables,
                nonLookupColumnNameToObjectPropertyMapper,
                lookupColumnNameToObjectPropertyMapper,
                airtableAPIModelImportsCollector,
                restAPIModelImportsCollector,
                views: filteredViews,
                labelPlural,
                labelSingular,
                queryableLookupFields,
                queryableNonLookupFields,
                restAPIModelExtrasCollector,
                columnNameToValidationSchemaTypeStringGroupMapper,
                includeAirtableSpecificQueryParameters,
                alternativeRecordIdColumns,
              });
            //#endregion

            // Replacing interpolation templates in template file contents
            const getInterpolatedString = (templateFileContents: string) => {
              return Object.keys(interpolationLabels).reduce(
                (fileContents, key) => {
                  return fileContents.replaceAll(key, interpolationLabels[key]);
                },
                Object.keys(interpolationBlocks).reduce((fileContents, key) => {
                  const escapedKey = RegExp.escape(key);
                  return fileContents.replace(
                    new RegExp(`${escapedKey}([\\s\\S]*?)${escapedKey}`, 'g'),
                    interpolationBlocks[key]
                  );
                }, templateFileContents)
              );
            };

            //#region Write generated API files based on templates
            await Promise.all(
              airtableTableScopedTemplateFilePaths.map(
                async (templateFilePath) => {
                  const filePath = getInterpolatedString(
                    `${baseAPIOutputFolderPath}${templateFilePath.replace(
                      templatesFolderPath,
                      ''
                    )}`
                  );
                  if (!existsSync(filePath)) {
                    const templateFileContents = readFileSync(
                      templateFilePath,
                      'utf-8'
                    );
                    let fileContents = `
                ${autogeneratedFileWarningComment}\n
                ${getInterpolatedString(templateFileContents)}
              `.trimIndent();

                    //#region Replace tsed controller template variables
                    if (templateFilePath.match(/Controller\.(ts|js)$/g)) {
                      const controllerTemplateVariables = {
                        TSED_CONTROLLER_FIND_FIRST_PAGE_DESCRIPTION_SUFFIX: '',
                        TSED_CONTROLLER_FIND_ALL_DESCRIPTION_SUFFIX: '',
                        TSED_CONTROLLER_FIND_BY_ID_DESCRIPTION_SUFFIX: '',
                      };
                      const findByIdDescriptionSuffixParts: string[] = [];
                      if (
                        alternativeRecordIdColumns &&
                        alternativeRecordIdColumns.length > 0
                      ) {
                        const alternativeRecordIdColumnsPhrase =
                          alternativeRecordIdColumns
                            .map((columnName) => {
                              return (
                                nonLookupColumnNameToObjectPropertyMapper[
                                  columnName
                                ]?.propertyName || columnName
                              );
                            })
                            .map((propertyName) => `\`${propertyName}\``)
                            .join(', ');
                        findByIdDescriptionSuffixParts.push(
                          `Besides the primary \`id\` field, the following fields can also be used on this path: ${alternativeRecordIdColumnsPhrase}.`
                        );
                      }
                      if (findByIdDescriptionSuffixParts.length > 0) {
                        controllerTemplateVariables.TSED_CONTROLLER_FIND_BY_ID_DESCRIPTION_SUFFIX = ` ${findByIdDescriptionSuffixParts.join(
                          ' '
                        )}`;
                      }

                      if (alternativeRecordIdColumns) {
                        controllerTemplateVariables.TSED_CONTROLLER_FIND_BY_ID_DESCRIPTION_SUFFIX;
                      }

                      Object.entries(controllerTemplateVariables).forEach(
                        ([variable, value]) => {
                          fileContents = fileContents.replaceAll(
                            `%${variable}%`,
                            value
                          );
                        }
                      );
                    }
                    //#endregion

                    //#region Add all entity permissions export
                    if (
                      templateFilePath.match(
                        new RegExp(
                          `${RegExp.escape(sep)}permissions${RegExp.escape(
                            sep
                          )}\\w+.(ts|js)$`,
                          'g'
                        )
                      )
                    ) {
                      fileContents += getInterpolatedString(
                        `\n\nexport const allPascalCaseEntitiesPermissions = [\n${modulePermissionsTemplate}\n]`
                      );
                    }
                    //#endregion

                    ensureDirSync(dirname(filePath));
                    writeFileSync(
                      filePath,
                      await prettier.format(fileContents, {
                        filepath: filePath,
                        ...prettierConfig,
                      })
                    );
                  }
                }
              )
            );
            //#endregion

            // Permissions
            //#region Accumulating all focus table permissions
            addModuleImport({
              imports: permissionsImports,
              importFilePath: getInterpolatedString(`./PascalCaseEntities`),
              importName: getInterpolatedString(
                `allPascalCaseEntitiesPermissions`
              ),
            });
            permissionsExports.push(
              getInterpolatedString(`export * from './PascalCaseEntities';`)
            );
            permissionsObjectStrings.push(
              getInterpolatedString(`...allPascalCaseEntitiesPermissions`)
            );
            //#endregion

            return {
              ...table,
              nonLookupColumnNameToObjectPropertyMapper,
              lookupColumnNameToObjectPropertyMapper,
              lookupColumnNameToParentColumnNameMap,
              labelPlural,
              labelSingular,
            };
          })
        );

        await Promise.all(
          airtableBaseScopedTemplateFiles.map(async (templateFilePath) => {
            const filePath = `${baseAPIOutputFolderPath}${templateFilePath.replace(
              templatesFolderPath,
              ''
            )}`;
            if (!existsSync(filePath)) {
              const templateFileContents = readFileSync(
                templateFilePath,
                'utf-8'
              );
              const interpolationBlocks = {
                ['/* AIRTABLE_SPECIFIC_QUERY_PARAMETERS */']: (() => {
                  if (!includeAirtableSpecificQueryParameters) {
                    return '';
                  }
                  return '$1';
                })(),
                ['/* AIRTABLE_TABLE_ID_TO_ENTITY_MAP */']: JSON.stringify(
                  Object.fromEntries(
                    filteredTablesConfigurations.map(
                      ({
                        id,
                        name,
                        labelPlural,
                        labelSingular,
                        primaryFieldId,
                      }) => {
                        return [
                          id,
                          {
                            id,
                            tableName: name,
                            entitiesPluralName: labelPlural.toPascalCase(),
                            entitySingularName: labelSingular.toPascalCase(),
                            primaryFieldId,
                          },
                        ];
                      }
                    )
                  ),
                  null,
                  2
                ),
                ['/* AIRTABLE_TABLE_COLUMN_ID_TO_FIELD_MAP */']: JSON.stringify(
                  Object.fromEntries(
                    filteredTablesConfigurations.flatMap(
                      ({
                        nonLookupColumnNameToObjectPropertyMapper,
                        lookupColumnNameToObjectPropertyMapper,
                        lookupColumnNameToParentColumnNameMap,
                        id: tableId,
                        name: tableName,
                      }) => {
                        return [
                          ...Object.entries(
                            nonLookupColumnNameToObjectPropertyMapper
                          ).map(([columnName, { id, propertyName }]) => {
                            return [
                              id,
                              {
                                id,
                                columnName,
                                entityPropertyPath: propertyName,
                                tableId,
                                tableName,
                              },
                            ];
                          }),
                          ...Object.entries(
                            lookupColumnNameToObjectPropertyMapper
                          ).map(([columnName, { id, propertyName }]) => {
                            return [
                              id,
                              {
                                id,
                                columnName,
                                entityPropertyPath: `"${
                                  nonLookupColumnNameToObjectPropertyMapper[
                                    lookupColumnNameToParentColumnNameMap[
                                      columnName
                                    ]
                                  ].propertyName
                                }.${propertyName}"`,
                                tableId,
                                tableName,
                              },
                            ];
                          }),
                        ];
                      }
                    )
                  ),
                  null,
                  2
                ),
                ['/* PROPERTY_PATHS_BY_ENTITY_NAME */']: JSON.stringify(
                  Object.fromEntries(
                    filteredTablesConfigurations
                      .map(
                        ({
                          labelPlural,
                          nonLookupColumnNameToObjectPropertyMapper,
                          lookupColumnNameToObjectPropertyMapper,
                          lookupColumnNameToParentColumnNameMap,
                        }) => {
                          return [
                            labelPlural.toPascalCase(),
                            [
                              ...Object.entries(
                                nonLookupColumnNameToObjectPropertyMapper
                              ).map(([, { propertyName }]) => {
                                return propertyName;
                              }),
                              ...Object.entries(
                                lookupColumnNameToObjectPropertyMapper
                              ).map(([columnName, { propertyName }]) => {
                                return `${
                                  nonLookupColumnNameToObjectPropertyMapper[
                                    lookupColumnNameToParentColumnNameMap[
                                      columnName
                                    ]
                                  ].propertyName
                                }.${propertyName}`;
                              }),
                            ].sort(),
                          ] as [string, string[]];
                        }
                      )
                      .sort(([aEntityName], [bEntityName]) => {
                        return aEntityName.localeCompare(bEntityName);
                      })
                  ),
                  null,
                  2
                ),
              };

              const fileContents = `
              ${autogeneratedFileWarningComment}\n
              ${Object.entries(interpolationBlocks).reduce(
                (fileContents, [key, interpolationValue]) => {
                  const escapedKey = RegExp.escape(key);
                  return fileContents.replace(
                    new RegExp(`${escapedKey}([\\s\\S]*?)${escapedKey}`, 'g'),
                    interpolationValue
                  );
                },
                templateFileContents
              )}
            `.trimIndent();

              ensureDirSync(dirname(filePath));
              writeFileSync(
                filePath,
                await prettier.format(fileContents, {
                  filepath: filePath,
                  ...prettierConfig,
                })
              );
            }
          })
        );
        //#endregion

        //#region Write api index file
        const apiModulesIndexFilePath = `${baseAPIOutputFolderPath}/api/index.ts`;
        if (!existsSync(apiModulesIndexFilePath)) {
          const fileContents = filteredTablesConfigurations
            .map(({ labelPlural }) => {
              return `export * from './${labelPlural.toPascalCase()}'`;
            })
            .join('\n');
          writeFileSync(
            apiModulesIndexFilePath,
            await prettier.format(
              `
              ${autogeneratedFileWarningComment}\n
              ${fileContents}
            `.trimIndent(),
              {
                filepath: apiModulesIndexFilePath,
                ...prettierConfig,
              }
            )
          );
        }
        //#endregion

        //#region Write models index file
        const modelsIndexFilePath = `${baseAPIOutputFolderPath}/models/index.ts`;
        if (!existsSync(modelsIndexFilePath)) {
          const fileContents = [
            ...filteredTablesConfigurations.map(({ labelPlural }) => {
              return labelPlural.toPascalCase();
            }),
            'Utils',
          ]
            .map((moduleName) => {
              return `export * from './${moduleName}'`;
            })
            .join('\n');
          writeFileSync(
            modelsIndexFilePath,
            await prettier.format(
              `
              ${autogeneratedFileWarningComment}\n
              ${fileContents}
            `.trimIndent(),
              {
                filepath: modelsIndexFilePath,
                ...prettierConfig,
              }
            )
          );
        }
        //#endregion

        //#region Write permissions index file
        const permissionsFilePath = `${baseAPIOutputFolderPath}/permissions/index.ts`;
        const permissionDependencies = filteredTablesConfigurations
          .map(
            ({ editableFieldsDependentTables, labelSingular, labelPlural }) => {
              const permissionsDependencies: {
                labelPlural: string;
                map: Record<string, string[]>;
              } = { labelPlural, map: {} };
              const [createPermissionDependencies, editPermissionDependencies] =
                [
                  editableFieldsDependentTables.filter(
                    ({ creatable = true, editable = true }) => {
                      return creatable && editable;
                    }
                  ),
                  editableFieldsDependentTables.filter(
                    ({ editable = true }) => {
                      return editable;
                    }
                  ),
                ].map((fieldsDependentTables) => {
                  return fieldsDependentTables.flatMap(({ tableColumn }) => {
                    const dependentTableConfiguration =
                      filteredTablesConfigurations.find(
                        ({ id: filteredTableId }) =>
                          tableColumn.options?.linkedTableId === filteredTableId
                      );

                    if (!dependentTableConfiguration) {
                      throw new Error(
                        `Dependent table configuration not found for column: ${tableColumn.name}`
                      );
                    }

                    const permissons = [
                      `VIEW_${dependentTableConfiguration.labelPlural
                        .toUpperCase()
                        .replace(/\s/g, '_')}_PERMISSION`,
                      `VIEW_${dependentTableConfiguration.labelSingular
                        .toUpperCase()
                        .replace(/\s/g, '_')}_DETAILS_PERMISSION`,
                    ];

                    permissons.forEach((permission) => {
                      addModuleImport({
                        imports: permissionsImports,
                        importFilePath: `./${dependentTableConfiguration.labelPlural.toPascalCase()}`,
                        importName: permission,
                      });
                    });
                    return permissons;
                  });
                });
              if (createPermissionDependencies.length > 0) {
                const createPermission = `CREATE_${labelSingular
                  .toUpperCase()
                  .replace(/\s/g, '_')}_PERMISSION`;
                addModuleImport({
                  imports: permissionsImports,
                  importFilePath: `./${labelPlural.toPascalCase()}`,
                  importName: createPermission,
                });
                permissionsDependencies.map[createPermission] =
                  createPermissionDependencies;
              }
              if (editPermissionDependencies.length > 0) {
                const updatePermission = `UPDATE_${labelSingular
                  .toUpperCase()
                  .replace(/\s/g, '_')}_PERMISSION`;
                addModuleImport({
                  imports: permissionsImports,
                  importFilePath: `./${labelPlural.toPascalCase()}`,
                  importName: updatePermission,
                });
                permissionsDependencies.map[updatePermission] =
                  editPermissionDependencies;
              }
              return permissionsDependencies;
            }
          )
          .filter(({ map }) => {
            return !isEmpty(map);
          });

        const dependentPermissionsObjectPropertiesCode = permissionDependencies
          .sort(
            ({ labelPlural: aLabelPlural }, { labelPlural: bLabelPlural }) => {
              return aLabelPlural.localeCompare(bLabelPlural);
            }
          )
          .map(({ labelPlural, map: entityPermissionDependencies }) => {
            const permissionDependenciesCodeBlock = Object.entries(
              entityPermissionDependencies
            )
              .map(([permission, dependantPermissions]) => {
                return `[${permission}]: [${dependantPermissions.join(', ')}],`;
              })
              .join('\n');
            return `
              //#region ${labelPlural} Permissions
              ${permissionDependenciesCodeBlock}
              //#endregion
            `.trimIndent();
          })
          .join('\n\n');

        writeFileSync(
          permissionsFilePath,
          await prettier.format(
            `
            ${autogeneratedFileWarningComment}\n
            ${getImportsCode({ imports: permissionsImports }).join('\n')}\n
            ${permissionsExports.sort().join('\n')}

            //#region All Permissions
            export const allPermissions = [\n${permissionsObjectStrings.join(
              ',\n'
            )}\n];
            //#endregion

            //#region Permission Dependencies Map
            export const dependenciesPermissionsMap = {\n${dependentPermissionsObjectPropertiesCode}\n};
            //#endregion
          `.trimIndent(),
            {
              filepath: permissionsFilePath,
              ...prettierConfig,
            }
          )
        );
        //#endregion

        //#region Write base index file
        const indexFilePath = `${baseAPIOutputFolderPath}/index.ts`;
        if (!existsSync(indexFilePath)) {
          const indexFileContents = ['api', 'models', 'permissions']
            .map((filePath) => {
              return `export * from './${filePath}'`;
            })
            .join('\n');
          writeFileSync(
            indexFilePath,
            await prettier.format(
              `
              ${autogeneratedFileWarningComment}\n
              ${indexFileContents}
            `.trimIndent(),
              {
                filepath: indexFilePath,
                ...prettierConfig,
              }
            )
          );
        }
        //#endregion

        console.log(
          `\n\x1b[32mAirtable [${workingBaseName.trim()}] base API generated here: ${baseAPIOutputFolderPath}\x1b[0m`
        );
      }
      //#endregion
    });
    //#endregion
  }
};
