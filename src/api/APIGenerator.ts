import '@infinite-debugger/rmk-js-extensions/RegExp';
import '@infinite-debugger/rmk-js-extensions/String';

import { dirname, join, normalize, sep } from 'path';

import {
  ensureDirSync,
  existsSync,
  readFileSync,
  unlinkSync,
  writeFileSync,
} from 'fs-extra';
import { isEmpty, pick } from 'lodash';
import pluralize from 'pluralize';
import prettier from 'prettier';
import { default as walk, default as walkSync } from 'walk-sync';

import { pkg } from '../config';
import {
  AirtableFieldType,
  Config,
  ConfigDetailedColumnNameToObjectPropertyMapper,
  DetailedColumnNameToObjectPropertyMapping,
  UserEditableDetailedColumnNameToObjectPropertyMapping,
} from '../models';
import {
  getEntityTemplateFileInterpolationBlocks,
  getEntityTemplateFileInterpolationLabels,
} from './InterpolationValuesGenerator';
import {
  ModelClass,
  TableColumnValidationSchemaTypeStringGroup,
  getExpandedAirtableLookupColumn,
  getTableColumnValidationSchemaTypeStrings,
} from './TypeGenerator';
import { extractUserDefinedBasesAndTables } from './UserConfigTableExtractor';
import {
  ModuleImports,
  addModuleImport,
  cleanEmptyFoldersRecursively,
  getCamelCaseFieldPropertyName,
  getGeneratedFileWarningComment,
  getImportsCode,
} from './Utils';

const prettierConfig: prettier.Options = {
  semi: true,
  trailingComma: 'es5',
  singleQuote: true,
  printWidth: 80,
  tabWidth: 2,
  endOfLine: 'auto',
};

const airtableAPIFolderName = 'Airtable';

//#region CONSTANTS
const LOOKUP_TABLE_COLUMN_TYPES: AirtableFieldType[] = [
  'lookup',
  'multipleLookupValues',
];

const DEFAULT_VIEW_NAME = 'Grid view';
const DEFAULT_VIEW_ALIAS = 'Default';
//#endregion

export interface GenerateAirtableAPIConfig {
  userConfig: Config<string>;
  outputRootPath: string;
  generateAllTables?: boolean;
}

export const generateAirtableAPI = async ({
  userConfig,
  outputRootPath,
  generateAllTables = false,
}: GenerateAirtableAPIConfig) => {
  //#region Initialization
  console.log('Generating airtable API...');
  const autogeneratedFileWarningComment = getGeneratedFileWarningComment();
  //#endregion

  const includeAirtableSpecificQueryParameters =
    userConfig.includeAirtableSpecificQueryParameters;

  const outputFolderPath = normalize(
    `${outputRootPath}/${airtableAPIFolderName}`
  );

  //#region Template files
  const templatesFolderPath = normalize(join(__dirname, '../template-files'));
  const airtableBaseScopedTemplateFiles = ['models/Utils.ts'].map(
    (fileName) => {
      return normalize(join(templatesFolderPath, fileName));
    }
  );
  const airtableTableScopedTemplateFilePaths = walk(templatesFolderPath, {
    includeBasePath: true,
    directories: false,
  })
    .map((filePath) => normalize(filePath))
    .filter((filePath) => {
      return (
        !filePath.match(/\.(template|placeholder)\.\w+$/g) &&
        !airtableBaseScopedTemplateFiles.includes(filePath)
      );
    });
  const modulePermissionsTemplate = readFileSync(
    join(
      __dirname,
      '../template-files/permissions/__entity_permissions_group.template.txt'
    ),
    'utf-8'
  );
  //#endregion

  const { bases: workingBases, configTables } =
    await extractUserDefinedBasesAndTables({
      userConfig,
      generateAllTables,
    });

  if (workingBases.length > 0) {
    //#region Clean up output directory
    if (existsSync(outputRootPath)) {
      walkSync(outputRootPath, {
        includeBasePath: true,
        directories: false,
      }).forEach((filePath) => {
        const fileContents = readFileSync(filePath, 'utf8');
        if (
          fileContents.match(
            `automatically generated by the ${pkg.name} library`
          )
        ) {
          console.log(`  -> Removing file: ${filePath}`);
          unlinkSync(filePath);
        }
      });
      cleanEmptyFoldersRecursively(outputRootPath);
    }
    ensureDirSync(outputFolderPath);
    //#endregion

    //#region Processing each focus airtable base
    workingBases.forEach(async (workingBase) => {
      const {
        id: workingBaseId,
        name: workingBaseName,
        userDefinedTables,
        tables,
      } = workingBase;

      //#region Prcess base if focus tables are found
      if (userDefinedTables.length > 0) {
        console.log(
          `\nProcessing \x1b[34m${workingBaseName.trim()}\x1b[0m base...`
        );

        const pascalCaseBaseName = workingBaseName.toPascalCase();
        const baseAPIOutputFolderPath = normalize(
          `${outputFolderPath}/${pascalCaseBaseName}`
        );

        //#region Permissions exports
        const permissionsImports: ModuleImports = {};
        const permissionsExports: string[] = [];
        const permissionsObjectStrings: string[] = [];
        //#endregion

        //#region Processing each focus tables.
        const filteredTablesConfigurations = userDefinedTables.map((table) => {
          const { name: tableName, fields: columns, views } = table;

          //#region User defined table configuration
          const {
            labelPlural,
            labelSingular,
            focusColumns: focusColumnNames = columns.map(({ name }) => name),
            configColumnNameToObjectPropertyMapper,
            configViews,
            alternativeRecordIdColumns,
          } = (() => {
            const outputConfig: {
              labelPlural: string;
              labelSingular: string;
              focusColumns?: string[];
              configColumnNameToObjectPropertyMapper: ConfigDetailedColumnNameToObjectPropertyMapper<string>;
              configViews?: string[];
              alternativeRecordIdColumns?: string[];
            } = {
              labelPlural: '',
              labelSingular: '',
              configColumnNameToObjectPropertyMapper: {},
            };

            // Finding table definition in user config
            const configTable = configTables.find(({ name, base }) => {
              return (
                name.trim() === tableName.trim() &&
                ((base.id && base.id === workingBaseId) ||
                  (base.name && base.name.trim() === workingBaseName.trim()))
              );
            });

            if (configTable) {
              const {
                alias: configTableAlias,
                name: configTableName,
                focusColumns,
                columnNameToObjectPropertyMapper:
                  configColumnNameToObjectPropertyMapper,
                views,
                alternativeRecordIdColumns,
              } = configTable;
              if (configTable.labelPlural) {
                outputConfig.labelPlural = configTable.labelPlural;
              } else {
                const sanitisedTableName = (configTableAlias || configTableName)
                  .trim()
                  .replace(/[^\w\s]/g, '');
                outputConfig.labelPlural = pluralize(sanitisedTableName);
              }
              if (configTable.labelSingular) {
                outputConfig.labelSingular = configTable.labelSingular;
              } else {
                const labelPlural = outputConfig.labelPlural!;
                outputConfig.labelSingular = pluralize.singular(labelPlural);
              }
              if (focusColumns) {
                Object.assign(
                  outputConfig.configColumnNameToObjectPropertyMapper,
                  Object.fromEntries(
                    focusColumns
                      .map((focusColumn) => {
                        if (Array.isArray(focusColumn)) {
                          return focusColumn;
                        }
                      })
                      .filter((focusColumn) => focusColumn) as [
                      string,
                      UserEditableDetailedColumnNameToObjectPropertyMapping
                    ][]
                  )
                );
                outputConfig.focusColumns = focusColumns.map((focusColumn) => {
                  if (Array.isArray(focusColumn)) {
                    return focusColumn[0];
                  }
                  return focusColumn;
                });
              }
              if (configColumnNameToObjectPropertyMapper) {
                Object.assign(
                  outputConfig.configColumnNameToObjectPropertyMapper,
                  Object.fromEntries(
                    Object.entries(configColumnNameToObjectPropertyMapper).map(
                      ([key, value]) => {
                        return [
                          key,
                          typeof value === 'string'
                            ? {
                                propertyName: value,
                              }
                            : value,
                        ];
                      }
                    )
                  )
                );
              }
              views && (outputConfig.configViews = views);
              alternativeRecordIdColumns &&
                (outputConfig.alternativeRecordIdColumns =
                  alternativeRecordIdColumns);
            } else {
              const sanitisedTableName = tableName
                .trim()
                .replace(/[^\w\s]/g, '');
              outputConfig.labelPlural = pluralize(sanitisedTableName);
              outputConfig.labelSingular = pluralize.singular(
                outputConfig.labelPlural
              );
            }

            return outputConfig;
          })();
          //#endregion

          //#region Filtering views
          const filteredViews = views
            .sort((a, b) => a.name.localeCompare(b.name))
            .filter(({ name }) => {
              return !configViews || configViews.includes(name);
            })
            .reduce(
              (accumulator, { name }) => {
                if (!accumulator.includes(name) && name !== DEFAULT_VIEW_NAME) {
                  accumulator.push(name);
                }
                return accumulator;
              },
              [DEFAULT_VIEW_ALIAS] as string[]
            );
          //#endregion

          const filteredTableColumns = focusColumnNames
            .map((focusColumnName) => {
              return columns.find(({ name }) => name === focusColumnName)!;
            })
            .filter((column) => column)
            .filter(({ name }) => {
              return (
                name.replace(/[^\w\s]/g, '').length > 0 && !name.match(/^id$/gi)
              );
            })
            .map((column) => {
              const fieldOverride =
                configColumnNameToObjectPropertyMapper[column.name]
                  ?.fieldOverride;
              if (fieldOverride) {
                return {
                  ...pick(column, 'id', 'name', 'description'),
                  ...fieldOverride,
                };
              }
              return column;
            });

          const nonLookupTableColumns = filteredTableColumns
            .filter(({ type }) => {
              return !type || !LOOKUP_TABLE_COLUMN_TYPES.includes(type);
            })
            .reduce<typeof filteredTableColumns>((accumulator, field) => {
              // Filtering columns with similar names.
              if (!accumulator.find(({ name }) => name === field.name)) {
                accumulator.push(field);
              }
              return accumulator;
            }, []);

          const lookupTableColumns = filteredTableColumns
            .filter(({ type, options }) => {
              // Making sure the lookup column has a parent field on the table.
              return (
                type === 'multipleLookupValues' &&
                options?.recordLinkFieldId &&
                filteredTableColumns.find(
                  ({ id }) => id === options?.recordLinkFieldId
                ) != null
              );
            })
            .reduce((accumulator, field) => {
              // Filtering lookup columns with similar references.
              if (
                !accumulator.find(({ options }) => {
                  return (
                    options?.recordLinkFieldId &&
                    options?.fieldIdInLinkedTable &&
                    field.options?.recordLinkFieldId &&
                    field.options?.fieldIdInLinkedTable &&
                    options.recordLinkFieldId ===
                      field.options.recordLinkFieldId &&
                    options.fieldIdInLinkedTable ===
                      field.options.fieldIdInLinkedTable
                  );
                })
              ) {
                accumulator.push(field);
              }
              return accumulator;
            }, [] as typeof columns);

          // Lookup column name to parent column name map
          const lookupColumnNameToParentColumnNameMap =
            lookupTableColumns.reduce((accumulator, { name, options }) => {
              const parentColumn = columns.find(
                ({ id }) => id === options?.recordLinkFieldId
              );
              if (parentColumn) {
                accumulator[name] = parentColumn.name;
              } else {
                console.log(`No parent column found for ${name}`);
              }
              return accumulator;
            }, {} as Record<string, string>);

          // Finding editable table columns
          const editableTableColumns = nonLookupTableColumns.filter(
            ({ type }) => {
              switch (type) {
                case 'singleLineText':
                case 'multilineText':
                case 'richText':
                case 'phoneNumber':
                case 'singleSelect':
                case 'url':
                case 'email':
                case 'number':
                case 'percent':
                case 'currency':
                case 'rating':
                case 'checkbox':
                case 'multipleRecordLinks':
                case 'date':
                case 'dateTime':
                case 'multipleSelects':
                  return true;
              }
              return false;
            }
          );

          // TODO: Make imports objects with setting keys as paths and values as a list of import objects.
          const airtableAPIModelImportsCollector: string[] = [];
          const restAPIModelImportsCollector: string[] = [];
          const restAPIModelExtrasCollector: ModelClass[] = [];

          console.log(
            `  -> Processing \x1b[34m${workingBaseName.trim()}/${JSON.stringify(
              tableName
            )}\x1b[0m table...`
          );

          const nonLookupColumnNameToObjectPropertyMapper =
            nonLookupTableColumns.reduce<
              Record<
                string,
                DetailedColumnNameToObjectPropertyMapping & {
                  tableColumn: (typeof nonLookupTableColumns)[number];
                }
              >
            >((accumulator, tableColumn) => {
              accumulator[tableColumn.name] = {
                ...configColumnNameToObjectPropertyMapper[tableColumn.name],
                id: tableColumn.id,
                propertyName: (() => {
                  // Extracting column object property name from user config.
                  if (
                    configColumnNameToObjectPropertyMapper[tableColumn.name]
                      ?.propertyName
                  ) {
                    return configColumnNameToObjectPropertyMapper[
                      tableColumn.name
                    ]!.propertyName!.split('.')[0];
                  }
                  return getCamelCaseFieldPropertyName(tableColumn); // Automatically converting table column name to camel case object property name
                })(),
                ...(() => {
                  // Extracting prefer single record link
                  const prefersSingleRecordLink = Boolean(
                    tableColumn.options?.prefersSingleRecordLink ||
                      configColumnNameToObjectPropertyMapper?.[tableColumn.name]
                        ?.prefersSingleRecordLink
                  );
                  if (prefersSingleRecordLink) {
                    return { prefersSingleRecordLink };
                  }
                })(),
                tableColumn,
              };
              return accumulator;
            }, {});

          //#region Sorting non lookup table columns
          nonLookupTableColumns.sort(({ name: aName }, { name: bName }) => {
            if (
              nonLookupColumnNameToObjectPropertyMapper[aName]?.propertyName &&
              nonLookupColumnNameToObjectPropertyMapper[bName]?.propertyName
            ) {
              return nonLookupColumnNameToObjectPropertyMapper[
                aName
              ].propertyName.localeCompare(
                nonLookupColumnNameToObjectPropertyMapper[bName].propertyName
              );
            }
            return 0;
          });
          //#endregion

          //#region Dependent table column ids.
          const editableFieldsDependentTables = Object.values(
            nonLookupColumnNameToObjectPropertyMapper
          )
            .filter(({ tableColumn: { type, options } }) => {
              return (
                type === 'multipleRecordLinks' &&
                options?.linkedTableId &&
                userDefinedTables.find(({ id }) => {
                  return id === options.linkedTableId;
                })
              );
            })
            .reduce<
              (typeof nonLookupColumnNameToObjectPropertyMapper)[string][]
            >((accumulator, column) => {
              if (
                !accumulator.find(({ id }) => {
                  return id === column.id;
                })
              ) {
                accumulator.push(column);
              }
              return accumulator;
            }, []);
          //#endregion

          const lookupColumnNameToObjectPropertyMapper =
            lookupTableColumns.reduce<
              Record<string, DetailedColumnNameToObjectPropertyMapping>
            >((accumulator, tableColumn) => {
              const parentField = (() => {
                const recordLinkFieldId =
                  tableColumn.options?.recordLinkFieldId;
                if (recordLinkFieldId) {
                  const recordLinkField = table.fields.find(
                    ({ id }) => id === recordLinkFieldId
                  );
                  if (recordLinkField) {
                    const linkedTableId =
                      recordLinkField.options?.linkedTableId;
                    const fieldIdInLinkedTable =
                      tableColumn.options?.fieldIdInLinkedTable;
                    if (linkedTableId && fieldIdInLinkedTable) {
                      const linkedTable = tables.find(
                        ({ id }) => id === linkedTableId
                      );
                      if (linkedTable) {
                        const linkedField = linkedTable.fields.find(
                          ({ id }) => id === fieldIdInLinkedTable
                        );
                        if (linkedField) {
                          return linkedField;
                        }
                      }
                    }
                  }
                }
                return tableColumn;
              })();

              const shouldFlattenLookupField = (
                lookupTableColumn: typeof tableColumn,
                lookupTable: typeof table
              ): boolean => {
                const referenceTableColumn = lookupTable.fields.find(
                  ({ id }) =>
                    id === lookupTableColumn.options?.recordLinkFieldId
                );
                const tablecolumnOneLevelUp = getExpandedAirtableLookupColumn(
                  lookupTableColumn,
                  tables,
                  lookupTable
                );

                if (
                  referenceTableColumn?.options?.prefersSingleRecordLink &&
                  tablecolumnOneLevelUp.type === 'multipleLookupValues'
                ) {
                  return shouldFlattenLookupField(
                    tablecolumnOneLevelUp,
                    tables.find(
                      ({ id }) =>
                        id === referenceTableColumn.options?.linkedTableId
                    )!
                  );
                }

                return Boolean(
                  referenceTableColumn?.options?.prefersSingleRecordLink &&
                    !(
                      [
                        'multipleLookupValues',
                        'multipleSelects',
                      ] as (typeof tablecolumnOneLevelUp.type)[]
                    ).includes(tablecolumnOneLevelUp.type)
                );
              };

              const flattenLookupField = shouldFlattenLookupField(
                tableColumn,
                table
              );

              accumulator[tableColumn.name] = {
                ...configColumnNameToObjectPropertyMapper[tableColumn.name],
                id: tableColumn.id,
                propertyName: (() => {
                  // Extracting column object property name from user config.
                  const propertyName = (() => {
                    if (
                      configColumnNameToObjectPropertyMapper[tableColumn.name]
                        ?.propertyName
                    ) {
                      return configColumnNameToObjectPropertyMapper[
                        tableColumn.name
                      ]!.propertyName;
                    }
                  })();

                  if (propertyName) {
                    if (propertyName.match(/\./g)) {
                      return propertyName.split('.').slice(-1)[0];
                    }
                    return propertyName;
                  }

                  return getCamelCaseFieldPropertyName(parentField); // Automatically converting parent table column name to camel case object property name
                })(),
                ...(() => {
                  if (flattenLookupField) {
                    return {
                      prefersSingleRecordLink: flattenLookupField,
                    };
                  }
                })(),
              } as DetailedColumnNameToObjectPropertyMapping;
              return accumulator;
            }, {});

          // Finding user defined queryable focus columns
          const queryableNonLookupFields = (focusColumnNames || [])
            .filter((columnName) => {
              return nonLookupColumnNameToObjectPropertyMapper[columnName];
            })
            .map((columnName) => {
              return `"${nonLookupColumnNameToObjectPropertyMapper[columnName].propertyName}"`;
            });

          // Finding user defined queryable focus columns
          const queryableLookupFields = (focusColumnNames || [])
            .filter((columnName) => {
              return lookupColumnNameToObjectPropertyMapper[columnName];
            })
            .map((columnName) => {
              return `"${
                nonLookupColumnNameToObjectPropertyMapper[
                  lookupColumnNameToParentColumnNameMap[columnName]
                ].propertyName
              }.${
                lookupColumnNameToObjectPropertyMapper[columnName].propertyName
              }"`;
            });

          // TODO: Merge all schema generation calls
          const columnNameToValidationSchemaTypeStringGroupMapper = [
            ...nonLookupTableColumns,
          ].reduce((accumulator, tableColumn) => {
            const tableColumnValidationSchemaTypeStrings =
              getTableColumnValidationSchemaTypeStrings(tableColumn, {
                airtableAPIModelImportsCollector,
                currentTable: table,
                tableLabelSingular: labelSingular,
                nonLookupColumnNameToObjectPropertyMapper,
                lookupColumnNameToObjectPropertyMapper,
                lookupTableColumns,
                restAPIModelExtrasCollector,
                restAPIModelImportsCollector,
                tables,
              });

            if (
              nonLookupColumnNameToObjectPropertyMapper[tableColumn.name]
                ?.required
            ) {
              tableColumnValidationSchemaTypeStrings.editModeDecorators ||
                (tableColumnValidationSchemaTypeStrings.editModeDecorators =
                  {});
              tableColumnValidationSchemaTypeStrings.editModeDecorators[
                'Required'
              ] = [];
            }

            if (
              nonLookupColumnNameToObjectPropertyMapper[tableColumn.name]
                ?.description &&
              (tableColumn.type !== 'multipleRecordLinks' ||
                !tableColumn.options?.prefersSingleRecordLink)
            ) {
              tableColumnValidationSchemaTypeStrings.decorators['Description'] =
                [
                  `${JSON.stringify(
                    nonLookupColumnNameToObjectPropertyMapper[tableColumn.name]
                      .description
                  )}`,
                ];
            }

            if (tableColumn.type === 'multipleRecordLinks') {
              const tableColumnModelExtras = restAPIModelExtrasCollector.find(
                ({ modelName }) => {
                  return (
                    modelName ===
                    tableColumnValidationSchemaTypeStrings.propertyType.replace(
                      /\[\]$/g,
                      ''
                    )
                  );
                }
              );
              if (tableColumnModelExtras) {
                const { modelProperties } = tableColumnModelExtras;
                modelProperties.forEach((modelProperty) => {
                  if (
                    lookupColumnNameToObjectPropertyMapper[
                      modelProperty.tableColumName
                    ]?.required
                  ) {
                    modelProperty.editModeDecorators ||
                      (modelProperty.editModeDecorators = {});
                    modelProperty.editModeDecorators['Required'] = [];
                  }
                  accumulator[modelProperty.tableColumName] = modelProperty;
                });
              }
            }

            accumulator[tableColumn.name] =
              tableColumnValidationSchemaTypeStrings;
            return accumulator;
          }, {} as Record<string, TableColumnValidationSchemaTypeStringGroup>);

          //#region Getting interpolation block replacement map
          const interpolationBlocks = getEntityTemplateFileInterpolationBlocks({
            base: workingBase,
            currentTable: table,
            nonLookupTableColumns,
            lookupTableColumns,
            editableTableColumns,
            tables,
            nonLookupColumnNameToObjectPropertyMapper,
            lookupColumnNameToObjectPropertyMapper,
            airtableAPIModelImportsCollector,
            restAPIModelImportsCollector,
            queryableLookupFields,
            queryableNonLookupFields,
            restAPIModelExtrasCollector,
            columnNameToValidationSchemaTypeStringGroupMapper,
            includeAirtableSpecificQueryParameters,
            alternativeRecordIdColumns,
          });
          //#endregion

          //#region Getting interpolation string replacement map
          const interpolationLabels = getEntityTemplateFileInterpolationLabels({
            currentTable: table,
            nonLookupTableColumns,
            lookupTableColumns,
            tables,
            nonLookupColumnNameToObjectPropertyMapper,
            lookupColumnNameToObjectPropertyMapper,
            airtableAPIModelImportsCollector,
            restAPIModelImportsCollector,
            views: filteredViews,
            labelPlural,
            labelSingular,
            queryableLookupFields,
            queryableNonLookupFields,
            restAPIModelExtrasCollector,
            columnNameToValidationSchemaTypeStringGroupMapper,
            includeAirtableSpecificQueryParameters,
            alternativeRecordIdColumns,
          });
          //#endregion

          // Replacing interpolation templates in template file contents
          const getInterpolatedString = (templateFileContents: string) => {
            return Object.keys(interpolationLabels).reduce(
              (fileContents, key) => {
                return fileContents.replaceAll(key, interpolationLabels[key]);
              },
              Object.keys(interpolationBlocks).reduce((fileContents, key) => {
                const escapedKey = RegExp.escape(key);
                return fileContents.replace(
                  new RegExp(`${escapedKey}([\\s\\S]*?)${escapedKey}`, 'g'),
                  interpolationBlocks[key]
                );
              }, templateFileContents)
            );
          };

          //#region Write generated API files based on templates
          airtableTableScopedTemplateFilePaths.forEach((templateFilePath) => {
            const filePath = getInterpolatedString(
              `${baseAPIOutputFolderPath}${templateFilePath.replace(
                templatesFolderPath,
                ''
              )}`
            );
            if (!existsSync(filePath)) {
              const templateFileContents = readFileSync(
                templateFilePath,
                'utf-8'
              );
              let fileContents = `
                ${autogeneratedFileWarningComment}\n
                ${getInterpolatedString(templateFileContents)}
              `.trimIndent();

              //#region Replace tsed controller template variables
              if (templateFilePath.match(/\Controller\.(ts|js)$/g)) {
                const controllerTemplateVariables = {
                  TSED_CONTROLLER_FIND_FIRST_PAGE_DESCRIPTION_SUFFIX: '',
                  TSED_CONTROLLER_FIND_ALL_DESCRIPTION_SUFFIX: '',
                  TSED_CONTROLLER_FIND_BY_ID_DESCRIPTION_SUFFIX: '',
                };
                const findByIdDescriptionSuffixParts: string[] = [];
                if (
                  alternativeRecordIdColumns &&
                  alternativeRecordIdColumns.length > 0
                ) {
                  const alternativeRecordIdColumnsPhrase =
                    alternativeRecordIdColumns
                      .map((columnName) => {
                        return (
                          nonLookupColumnNameToObjectPropertyMapper[columnName]
                            ?.propertyName || columnName
                        );
                      })
                      .map((propertyName) => `\`${propertyName}\``)
                      .join(', ');
                  findByIdDescriptionSuffixParts.push(
                    `Besides the primary \`id\` field, the following fields can also be used on this path: ${alternativeRecordIdColumnsPhrase}.`
                  );
                }
                if (findByIdDescriptionSuffixParts.length > 0) {
                  controllerTemplateVariables.TSED_CONTROLLER_FIND_BY_ID_DESCRIPTION_SUFFIX = ` ${findByIdDescriptionSuffixParts.join(
                    ' '
                  )}`;
                }

                if (alternativeRecordIdColumns) {
                  controllerTemplateVariables.TSED_CONTROLLER_FIND_BY_ID_DESCRIPTION_SUFFIX;
                }

                Object.entries(controllerTemplateVariables).forEach(
                  ([variable, value]) => {
                    fileContents = fileContents.replaceAll(
                      `%${variable}%`,
                      value
                    );
                  }
                );
              }
              //#endregion

              //#region Add all entity permissions export
              if (
                templateFilePath.match(
                  new RegExp(
                    `${RegExp.escape(sep)}permissions${RegExp.escape(
                      sep
                    )}\\w+.(ts|js)$`,
                    'g'
                  )
                )
              ) {
                fileContents += getInterpolatedString(
                  `\n\nexport const allPascalCaseEntitiesPermissions = [\n${modulePermissionsTemplate}\n]`
                );
              }
              //#endregion

              ensureDirSync(dirname(filePath));
              writeFileSync(
                filePath,
                prettier.format(fileContents, {
                  filepath: filePath,
                  ...prettierConfig,
                })
              );
            }
          });
          //#endregion

          // Permissions
          //#region Accumulating all focus table permissions
          addModuleImport({
            imports: permissionsImports,
            importFilePath: getInterpolatedString(`./PascalCaseEntities`),
            importName: getInterpolatedString(
              `allPascalCaseEntitiesPermissions`
            ),
          });
          permissionsExports.push(
            getInterpolatedString(`export * from './PascalCaseEntities';`)
          );
          permissionsObjectStrings.push(
            getInterpolatedString(`...allPascalCaseEntitiesPermissions`)
          );
          //#endregion

          return {
            ...table,
            nonLookupColumnNameToObjectPropertyMapper,
            lookupColumnNameToObjectPropertyMapper,
            lookupColumnNameToParentColumnNameMap,
            labelPlural,
            labelSingular,
            editableFieldsDependentTables,
          };
        });

        airtableBaseScopedTemplateFiles.forEach((templateFilePath) => {
          const filePath = `${baseAPIOutputFolderPath}${templateFilePath.replace(
            templatesFolderPath,
            ''
          )}`;
          if (!existsSync(filePath)) {
            const templateFileContents = readFileSync(
              templateFilePath,
              'utf-8'
            );
            const interpolationBlocks = {
              ['/* AIRTABLE_SPECIFIC_QUERY_PARAMETERS */']: (() => {
                if (!includeAirtableSpecificQueryParameters) {
                  return '';
                }
                return '$1';
              })(),
              ['/* AIRTABLE_TABLE_ID_TO_ENTITY_MAP */']: JSON.stringify(
                Object.fromEntries(
                  filteredTablesConfigurations.map(
                    ({
                      id,
                      name,
                      labelPlural,
                      labelSingular,
                      primaryFieldId,
                    }) => {
                      return [
                        id,
                        {
                          id,
                          tableName: name,
                          entitiesPluralName: labelPlural.toPascalCase(),
                          entitySingularName: labelSingular.toPascalCase(),
                          primaryFieldId,
                        },
                      ];
                    }
                  )
                ),
                null,
                2
              ),
              ['/* AIRTABLE_TABLE_COLUMN_ID_TO_FIELD_MAP */']: JSON.stringify(
                Object.fromEntries(
                  filteredTablesConfigurations.flatMap(
                    ({
                      nonLookupColumnNameToObjectPropertyMapper,
                      lookupColumnNameToObjectPropertyMapper,
                      lookupColumnNameToParentColumnNameMap,
                      id: tableId,
                      name: tableName,
                    }) => {
                      return [
                        ...Object.entries(
                          nonLookupColumnNameToObjectPropertyMapper
                        ).map(([columnName, { id, propertyName }]) => {
                          return [
                            id,
                            {
                              id,
                              columnName,
                              entityPropertyPath: propertyName,
                              tableId,
                              tableName,
                            },
                          ];
                        }),
                        ...Object.entries(
                          lookupColumnNameToObjectPropertyMapper
                        ).map(([columnName, { id, propertyName }]) => {
                          return [
                            id,
                            {
                              id,
                              columnName,
                              entityPropertyPath: `"${
                                nonLookupColumnNameToObjectPropertyMapper[
                                  lookupColumnNameToParentColumnNameMap[
                                    columnName
                                  ]
                                ].propertyName
                              }.${propertyName}"`,
                              tableId,
                              tableName,
                            },
                          ];
                        }),
                      ];
                    }
                  )
                ),
                null,
                2
              ),
              ['/* PROPERTY_PATHS_BY_ENTITY_NAME */']: JSON.stringify(
                Object.fromEntries(
                  filteredTablesConfigurations
                    .map(
                      ({
                        labelPlural,
                        nonLookupColumnNameToObjectPropertyMapper,
                        lookupColumnNameToObjectPropertyMapper,
                        lookupColumnNameToParentColumnNameMap,
                      }) => {
                        return [
                          labelPlural.toPascalCase(),
                          [
                            ...Object.entries(
                              nonLookupColumnNameToObjectPropertyMapper
                            ).map(([, { propertyName }]) => {
                              return propertyName;
                            }),
                            ...Object.entries(
                              lookupColumnNameToObjectPropertyMapper
                            ).map(([columnName, { propertyName }]) => {
                              return `${
                                nonLookupColumnNameToObjectPropertyMapper[
                                  lookupColumnNameToParentColumnNameMap[
                                    columnName
                                  ]
                                ].propertyName
                              }.${propertyName}`;
                            }),
                          ].sort(),
                        ] as [string, string[]];
                      }
                    )
                    .sort(([aEntityName], [bEntityName]) => {
                      return aEntityName.localeCompare(bEntityName);
                    })
                ),
                null,
                2
              ),
            };

            let fileContents = `
              ${autogeneratedFileWarningComment}\n
              ${Object.entries(interpolationBlocks).reduce(
                (fileContents, [key, interpolationValue]) => {
                  const escapedKey = RegExp.escape(key);
                  return fileContents.replace(
                    new RegExp(`${escapedKey}([\\s\\S]*?)${escapedKey}`, 'g'),
                    interpolationValue
                  );
                },
                templateFileContents
              )}
            `.trimIndent();

            ensureDirSync(dirname(filePath));
            writeFileSync(
              filePath,
              prettier.format(fileContents, {
                filepath: filePath,
                ...prettierConfig,
              })
            );
          }
        });
        //#endregion

        //#region Write api index file
        const apiModulesIndexFilePath = `${baseAPIOutputFolderPath}/api/index.ts`;
        if (!existsSync(apiModulesIndexFilePath)) {
          const fileContents = filteredTablesConfigurations
            .map(({ labelPlural }) => {
              return `export * from './${labelPlural.toPascalCase()}'`;
            })
            .join('\n');
          writeFileSync(
            apiModulesIndexFilePath,
            prettier.format(
              `
              ${autogeneratedFileWarningComment}\n
              ${fileContents}
            `.trimIndent(),
              {
                filepath: apiModulesIndexFilePath,
                ...prettierConfig,
              }
            )
          );
        }
        //#endregion

        //#region Write models index file
        const modelsIndexFilePath = `${baseAPIOutputFolderPath}/models/index.ts`;
        if (!existsSync(modelsIndexFilePath)) {
          const fileContents = [
            ...filteredTablesConfigurations.map(({ labelPlural }) => {
              return labelPlural.toPascalCase();
            }),
            'Utils',
          ]
            .map((moduleName) => {
              return `export * from './${moduleName}'`;
            })
            .join('\n');
          writeFileSync(
            modelsIndexFilePath,
            prettier.format(
              `
              ${autogeneratedFileWarningComment}\n
              ${fileContents}
            `.trimIndent(),
              {
                filepath: modelsIndexFilePath,
                ...prettierConfig,
              }
            )
          );
        }
        //#endregion

        //#region Write permissions index file
        const permissionsFilePath = `${baseAPIOutputFolderPath}/permissions/index.ts`;
        const permissionDependencies = filteredTablesConfigurations
          .map(
            ({ editableFieldsDependentTables, labelSingular, labelPlural }) => {
              const permissionsDependencies: {
                labelPlural: string;
                map: Record<string, string[]>;
              } = { labelPlural, map: {} };
              const [createPermissionDependencies, editPermissionDependencies] =
                [
                  editableFieldsDependentTables.filter(
                    ({ creatable = true, editable = true }) => {
                      return creatable && editable;
                    }
                  ),
                  editableFieldsDependentTables.filter(
                    ({ editable = true }) => {
                      return editable;
                    }
                  ),
                ].map((fieldsDependentTables) => {
                  return fieldsDependentTables.flatMap(({ tableColumn }) => {
                    const dependentTableConfiguration =
                      filteredTablesConfigurations.find(
                        ({ id: filteredTableId }) =>
                          tableColumn.options?.linkedTableId === filteredTableId
                      )!;
                    const permissons = [
                      `VIEW_${dependentTableConfiguration.labelPlural
                        .toUpperCase()
                        .replace(/\s/g, '_')}_PERMISSION`,
                      `VIEW_${dependentTableConfiguration.labelSingular
                        .toUpperCase()
                        .replace(/\s/g, '_')}_DETAILS_PERMISSION`,
                    ];

                    permissons.forEach((permission) => {
                      addModuleImport({
                        imports: permissionsImports,
                        importFilePath: `./${dependentTableConfiguration.labelPlural.toPascalCase()}`,
                        importName: permission,
                      });
                    });
                    return permissons;
                  });
                });
              if (createPermissionDependencies.length > 0) {
                const createPermission = `CREATE_${labelSingular
                  .toUpperCase()
                  .replace(/\s/g, '_')}_PERMISSION`;
                addModuleImport({
                  imports: permissionsImports,
                  importFilePath: `./${labelPlural.toPascalCase()}`,
                  importName: createPermission,
                });
                permissionsDependencies.map[createPermission] =
                  createPermissionDependencies;
              }
              if (editPermissionDependencies.length > 0) {
                const updatePermission = `UPDATE_${labelSingular
                  .toUpperCase()
                  .replace(/\s/g, '_')}_PERMISSION`;
                addModuleImport({
                  imports: permissionsImports,
                  importFilePath: `./${labelPlural.toPascalCase()}`,
                  importName: updatePermission,
                });
                permissionsDependencies.map[updatePermission] =
                  editPermissionDependencies;
              }
              return permissionsDependencies;
            }
          )
          .filter(({ map }) => {
            return !isEmpty(map);
          });

        const dependentPermissionsObjectPropertiesCode = permissionDependencies
          .sort(
            ({ labelPlural: aLabelPlural }, { labelPlural: bLabelPlural }) => {
              return aLabelPlural.localeCompare(bLabelPlural);
            }
          )
          .map(({ labelPlural, map: entityPermissionDependencies }) => {
            const permissionDependenciesCodeBlock = Object.entries(
              entityPermissionDependencies
            )
              .map(([permission, dependantPermissions]) => {
                return `[${permission}]: [${dependantPermissions.join(', ')}],`;
              })
              .join('\n');
            return `
              //#region ${labelPlural} Permissions
              ${permissionDependenciesCodeBlock}
              //#endregion
            `.trimIndent();
          })
          .join('\n\n');

        writeFileSync(
          permissionsFilePath,
          prettier.format(
            `
            ${autogeneratedFileWarningComment}\n
            ${getImportsCode({ imports: permissionsImports }).join('\n')}\n
            ${permissionsExports.sort().join('\n')}

            //#region All Permissions
            export const allPermissions = [\n${permissionsObjectStrings.join(
              ',\n'
            )}\n];
            //#endregion

            //#region Permission Dependencies Map
            export const dependenciesPermissionsMap = {\n${dependentPermissionsObjectPropertiesCode}\n};
            //#endregion
          `.trimIndent(),
            {
              filepath: permissionsFilePath,
              ...prettierConfig,
            }
          )
        );
        //#endregion

        //#region Write base index file
        const indexFilePath = `${baseAPIOutputFolderPath}/index.ts`;
        if (!existsSync(indexFilePath)) {
          const indexFileContents = ['api', 'models', 'permissions']
            .map((filePath) => {
              return `export * from './${filePath}'`;
            })
            .join('\n');
          writeFileSync(
            indexFilePath,
            prettier.format(
              `
              ${autogeneratedFileWarningComment}\n
              ${indexFileContents}
            `.trimIndent(),
              {
                filepath: indexFilePath,
                ...prettierConfig,
              }
            )
          );
        }
        //#endregion

        console.log(
          `\n\x1b[32mAirtable [${workingBaseName.trim()}] base API generated here: ${baseAPIOutputFolderPath}\x1b[0m`
        );
      }
      //#endregion
    });
    //#endregion
  }
};
